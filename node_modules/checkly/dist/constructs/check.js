"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Check = void 0;
const ref_1 = require("./ref");
const frequency_1 = require("./frequency");
const construct_1 = require("./construct");
const alert_channel_subscription_1 = require("./alert-channel-subscription");
const project_1 = require("./project");
const private_location_check_assignment_1 = require("./private-location-check-assignment");
// This is an abstract class. It shouldn't be used directly.
class Check extends construct_1.Construct {
    name;
    activated;
    muted;
    doubleCheck;
    shouldFail;
    runtimeId;
    locations;
    privateLocations;
    tags;
    frequency;
    frequencyOffset;
    environmentVariables;
    groupId;
    alertChannels;
    testOnly;
    retryStrategy;
    alertSettings;
    useGlobalAlertSettings;
    runParallel;
    triggerIncident;
    __checkFilePath; // internal variable to filter by check file name from the CLI
    static __checklyType = 'check';
    constructor(logicalId, props) {
        super(Check.__checklyType, logicalId);
        if (props.group) {
            Check.applyDefaultCheckGroupConfig(props, props.group.getCheckDefaults());
        }
        Check.applyDefaultCheckConfig(props);
        // TODO: Throw an error if required properties are still missing after applying the defaults.
        this.name = props.name;
        this.activated = props.activated;
        this.muted = props.muted;
        this.doubleCheck = props.doubleCheck;
        this.shouldFail = props.shouldFail;
        this.locations = props.locations;
        this.privateLocations = props.privateLocations;
        this.tags = props.tags;
        if (props.frequency instanceof frequency_1.Frequency) {
            this.frequency = props.frequency.frequency;
            this.frequencyOffset = props.frequency.frequencyOffset;
        }
        else {
            this.frequency = props.frequency;
        }
        this.runtimeId = props.runtimeId;
        this.environmentVariables = props.environmentVariables ?? [];
        // Alert channel subscriptions will be synthesized separately in the Project construct.
        // This is due to the way things are organized on the BE.
        this.alertChannels = props.alertChannels ?? [];
        // Prefer the `group` parameter, but support groupId for backwards compatibility.
        this.groupId = props.group?.ref() ?? props.groupId;
        // alertSettings, useGlobalAlertSettings, groupId, groupOrder
        this.testOnly = props.testOnly ?? false;
        this.retryStrategy = props.retryStrategy;
        this.alertSettings = props.alertEscalationPolicy;
        this.useGlobalAlertSettings = !this.alertSettings;
        this.runParallel = props.runParallel ?? false;
        this.triggerIncident = props.triggerIncident;
        this.__checkFilePath = project_1.Session.checkFilePath;
    }
    static applyDefaultCheckGroupConfig(props, groupProps) {
        let configKey;
        for (configKey in groupProps) {
            const newVal = props[configKey] ?? groupProps[configKey];
            props[configKey] = newVal;
        }
    }
    static applyDefaultCheckConfig(props) {
        if (!project_1.Session.checkDefaults) {
            return;
        }
        let configKey;
        for (configKey in project_1.Session.checkDefaults) {
            const newVal = props[configKey] ?? project_1.Session.checkDefaults[configKey];
            props[configKey] = newVal;
        }
    }
    addSubscriptions() {
        if (!this.alertChannels || this.testOnly) {
            return;
        }
        for (const alertChannel of this.alertChannels) {
            const subscription = new alert_channel_subscription_1.AlertChannelSubscription(`check-alert-channel-subscription#${this.logicalId}#${alertChannel.logicalId}`, {
                alertChannelId: ref_1.Ref.from(alertChannel.logicalId),
                checkId: ref_1.Ref.from(this.logicalId),
                activated: true,
            });
        }
    }
    addPrivateLocationCheckAssignments() {
        if (!this.privateLocations) {
            return;
        }
        for (const privateLocation of this.privateLocations) {
            // slugName strings are processed in loadAllPrivateLocations()
            if (typeof privateLocation === 'string') {
                continue;
            }
            // use private location assignment for instances
            const assignment = new private_location_check_assignment_1.PrivateLocationCheckAssignment(`private-location-check-assignment#${this.logicalId}#${privateLocation.logicalId}`, {
                privateLocationId: ref_1.Ref.from(privateLocation.logicalId),
                checkId: ref_1.Ref.from(this.logicalId),
            });
        }
    }
    getSourceFile() {
        return this.__checkFilePath;
    }
    synthesize() {
        const triggerIncident = (() => {
            if (this.triggerIncident) {
                const { service, ...triggerIncident } = this.triggerIncident;
                return {
                    ...triggerIncident,
                    serviceId: service.ref(),
                };
            }
        })();
        return {
            name: this.name,
            activated: this.activated,
            muted: this.muted,
            shouldFail: this.shouldFail,
            runtimeId: this.runtimeId,
            locations: this.locations,
            // private-location instances are assigned with loadAllPrivateLocations()
            privateLocations: undefined,
            tags: this.tags,
            frequency: this.frequency,
            frequencyOffset: this.frequencyOffset,
            groupId: this.groupId,
            environmentVariables: this.environmentVariables,
            // The backend doesn't actually support the `NO_RETRIES` type, it uses `null` instead.
            retryStrategy: this.retryStrategy?.type === 'NO_RETRIES'
                ? null
                : this.retryStrategy,
            // When `retryStrategy: NO_RETRIES` and `doubleCheck: undefined`, we want to let the user disable all retries.
            // The backend has a Joi default of `doubleCheck: true`, though, so we need special handling for this case.
            doubleCheck: this.doubleCheck === undefined && this.retryStrategy?.type === 'NO_RETRIES'
                ? false
                : this.doubleCheck,
            alertSettings: this.alertSettings,
            useGlobalAlertSettings: this.useGlobalAlertSettings,
            runParallel: this.runParallel,
            triggerIncident,
        };
    }
}
exports.Check = Check;
//# sourceMappingURL=check.js.map