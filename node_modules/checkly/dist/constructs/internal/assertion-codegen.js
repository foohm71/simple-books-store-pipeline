"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.valueForGeneralAssertion = exports.valueForNumericAssertion = void 0;
const sourcegen_1 = require("../../sourcegen");
function valueForNumericAssertion(klass, method, assertion) {
    return (0, sourcegen_1.expr)((0, sourcegen_1.ident)(klass), builder => {
        builder.member((0, sourcegen_1.ident)(method));
        builder.call(builder => {
            builder.empty();
        });
        switch (assertion.comparison) {
            case 'EQUALS':
                builder.member((0, sourcegen_1.ident)('equals'));
                builder.call(builder => {
                    builder.number(parseInt(assertion.target, 10));
                });
                break;
            case 'NOT_EQUALS':
                builder.member((0, sourcegen_1.ident)('notEquals'));
                builder.call(builder => {
                    builder.number(parseInt(assertion.target, 10));
                });
                break;
            case 'LESS_THAN':
                builder.member((0, sourcegen_1.ident)('lessThan'));
                builder.call(builder => {
                    builder.number(parseInt(assertion.target, 10));
                });
                break;
            case 'GREATER_THAN':
                builder.member((0, sourcegen_1.ident)('greaterThan'));
                builder.call(builder => {
                    builder.number(parseInt(assertion.target, 10));
                });
                break;
            default:
                throw new Error(`Unsupported comparison ${assertion.comparison} for assertion source ${assertion.source}`);
        }
    });
}
exports.valueForNumericAssertion = valueForNumericAssertion;
function valueForGeneralAssertion(klass, method, assertion) {
    return (0, sourcegen_1.expr)((0, sourcegen_1.ident)(klass), builder => {
        builder.member((0, sourcegen_1.ident)(method));
        builder.call(builder => {
            if (assertion.property !== '') {
                builder.string(assertion.property);
            }
        });
        switch (assertion.comparison) {
            case 'EQUALS':
                builder.member((0, sourcegen_1.ident)('equals'));
                builder.call(builder => {
                    builder.string(assertion.target);
                });
                break;
            case 'NOT_EQUALS':
                builder.member((0, sourcegen_1.ident)('notEquals'));
                builder.call(builder => {
                    builder.string(assertion.target);
                });
                break;
            case 'HAS_KEY':
                builder.member((0, sourcegen_1.ident)('hasKey'));
                builder.call(builder => {
                    builder.string(assertion.target);
                });
                break;
            case 'NOT_HAS_KEY':
                builder.member((0, sourcegen_1.ident)('notHasKey'));
                builder.call(builder => {
                    builder.string(assertion.target);
                });
                break;
            case 'HAS_VALUE':
                builder.member((0, sourcegen_1.ident)('hasValue'));
                builder.call(builder => {
                    builder.string(assertion.target);
                });
                break;
            case 'NOT_HAS_VALUE':
                builder.member((0, sourcegen_1.ident)('notHasValue'));
                builder.call(builder => {
                    builder.string(assertion.target);
                });
                break;
            case 'IS_EMPTY':
                builder.member((0, sourcegen_1.ident)('isEmpty'));
                builder.call(builder => {
                    builder.empty();
                });
                break;
            case 'NOT_EMPTY':
                builder.member((0, sourcegen_1.ident)('notEmpty'));
                builder.call(builder => {
                    builder.empty();
                });
                break;
            case 'LESS_THAN':
                builder.member((0, sourcegen_1.ident)('lessThan'));
                builder.call(builder => {
                    builder.string(assertion.target);
                });
                break;
            case 'GREATER_THAN':
                builder.member((0, sourcegen_1.ident)('greaterThan'));
                builder.call(builder => {
                    builder.string(assertion.target);
                });
                break;
            case 'CONTAINS':
                builder.member((0, sourcegen_1.ident)('contains'));
                builder.call(builder => {
                    builder.string(assertion.target);
                });
                break;
            case 'NOT_CONTAINS':
                builder.member((0, sourcegen_1.ident)('notContains'));
                builder.call(builder => {
                    builder.string(assertion.target);
                });
                break;
            case 'IS_NULL':
                builder.member((0, sourcegen_1.ident)('isNull'));
                builder.call(builder => {
                    builder.empty();
                });
                break;
            case 'NOT_NULL':
                builder.member((0, sourcegen_1.ident)('isNotNull'));
                builder.call(builder => {
                    builder.empty();
                });
                break;
            default:
                throw new Error(`Unsupported comparison ${assertion.comparison} for assertion source ${assertion.source}`);
        }
    });
}
exports.valueForGeneralAssertion = valueForGeneralAssertion;
//# sourceMappingURL=assertion-codegen.js.map