"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Context = exports.FilePath = exports.FriendVariableLocator = exports.GeneratedVariableLocator = exports.VariableLocator = exports.MissingContextVariableMappingError = void 0;
const node_path_1 = __importStar(require("node:path"));
const sourcegen_1 = require("../../../sourcegen");
const snippet_1 = require("./snippet");
class MissingContextVariableMappingError extends Error {
}
exports.MissingContextVariableMappingError = MissingContextVariableMappingError;
class VariableLocator {
    id;
    filePath;
    constructor(id, filePath) {
        this.id = id;
        this.filePath = filePath;
    }
}
exports.VariableLocator = VariableLocator;
class GeneratedVariableLocator extends VariableLocator {
    file;
    constructor(id, file) {
        super(id, file.path);
        this.file = file;
    }
}
exports.GeneratedVariableLocator = GeneratedVariableLocator;
class FriendVariableLocator extends VariableLocator {
}
exports.FriendVariableLocator = FriendVariableLocator;
const CHECKLY_IMPORT_FILENAME_TAG_PREFIX = 'checkly-import-filename:';
const splitExt = (filePath) => {
    const { dir, base } = node_path_1.default.parse(filePath);
    // Remove all extensions even if there are multiple.
    const index = base.indexOf('.');
    return index !== -1
        ? [node_path_1.default.join(dir, base.slice(0, index)), base.slice(index)]
        : [filePath, ''];
};
class FilePath {
    fullPath;
    constructor(fullPath) {
        this.fullPath = fullPath;
    }
    get extless() {
        const [value] = splitExt(this.fullPath);
        return value;
    }
}
exports.FilePath = FilePath;
/**
 * Creates a usable variable name from a fixed base component and a variable
 * name component.
 *
 * In order to keep variable names short and sensible, the base component
 * may or may not be included in the final result if its value is deemed
 * redundant.
 *
 * @example
 * formatVariable('group', 'Website Group') === 'websiteGroup'
 * formatVariable('group', 'Production') === 'productionGroup'
 * formatVariable('alert', 'ops email') === 'opsEmailAlert'
 * formatVariable('location', 'Office Rack #12') === 'officeRack12Location'
 * @param base Fixed base component
 * @param name Variable component
 * @returns Formatted variable name
 */
function formatVariable(base, name) {
    let prefix = (0, sourcegen_1.cased)(name, 'camelCase');
    // Even camelcased, the prefix may start with a number. Get rid of it.
    if (/^[0-9]+/.test(prefix)) {
        prefix = prefix.replace(/^[0-9]+/, '');
        prefix = (0, sourcegen_1.cased)(prefix, 'camelCase');
    }
    // Allow pretty long variables but set a hard limit. Limit does not include
    // the suffix.
    if (prefix.length > 64) {
        prefix = prefix.slice(0, 64);
    }
    // The name might consist of characters that all get stripped out. If so,
    // just use the base.
    if (prefix === '') {
        return (0, sourcegen_1.cased)(base, 'camelCase');
    }
    // Maybe the resource name already starts with the base. Can happen if the
    // resource name is "Group #123" and base is "group", which would result in
    // "group123Group" if the normal suffix was added. Instead, don't add the
    // suffix.
    if (prefix.startsWith(base)) {
        return prefix;
    }
    const suffix = (0, sourcegen_1.cased)(base, 'PascalCase');
    // Maybe the resource name already includes the base. For example,
    // if the resource name is "My Group" and the base "group", that would
    // then result in "myGroupGroup" which is weird. If so skip the suffix.
    if (prefix.endsWith(suffix)) {
        return prefix;
    }
    return prefix + suffix;
}
class Context {
    #alertChannelVariablesByPhysicalId = new Map();
    #alertChannelFriendVariablesByPhysicalId = new Map();
    #checkAlertChannelPhysicalIdsByPhysicalId = new Map();
    #checkPrivateLocationPhysicalIdsByPhysicalId = new Map();
    #checkGroupAlertChannelPhysicalIdsByPhysicalId = new Map();
    #checkGroupPrivateLocationPhysicalIdsByPhysicalId = new Map();
    #checkGroupVariablesByPhysicalId = new Map();
    #checkGroupFriendVariablesByPhysicalId = new Map();
    #privateLocationVariablesByPhysicalId = new Map();
    #privateLocationFriendVariablesByPhysicalId = new Map();
    #statusPageServiceVariablesByPhysicalId = new Map();
    #statusPageServiceFriendVariablesByPhysicalId = new Map();
    #knownSecrets = new Set();
    #knownFilePaths = new Map();
    #filePathContentKeys = new Map();
    #auxiliarySnippetFilesByPhysicalId = new Map();
    #auxiliarySnippetFilesByFilename = new Map();
    #reservedIdentifiersByFilePath = new Map();
    #reserveIdentifierForLocator(filePath, locator) {
        const fileVariables = this.#reservedIdentifiersByFilePath.get(filePath)
            ?? new Map();
        this.#reservedIdentifiersByFilePath.set(filePath, fileVariables);
        const name = locator.id.value;
        // First use? Let it through.
        const existingLocator = fileVariables.get(name);
        if (existingLocator === undefined) {
            fileVariables.set(name, locator);
            return locator.id;
        }
        // If we're reserving an identifier for the same locator as earlier, let
        // it through. The same identifier will work for our purposes.
        if (existingLocator === locator) {
            return locator.id;
        }
        // Nth use? Try to find the next available number, keeping in mind the
        // possibility that someone may have separately reserved a variable with
        // the same counter value at the end, which can happen if the base
        // variable name includes a number.
        //
        // Starts counting from 2 (first use has no counter appended).
        for (let nth = 2;; nth += 1) {
            const newName = `${name}${nth}`;
            const existingLocator = fileVariables.get(newName);
            if (existingLocator === undefined) {
                fileVariables.set(newName, locator);
                return new sourcegen_1.IdentifierValue(newName);
            }
            if (existingLocator === locator) {
                return new sourcegen_1.IdentifierValue(newName);
            }
        }
    }
    filePath(parent, hint, options) {
        let filename = (0, sourcegen_1.cased)(hint, options?.case ?? 'kebab-case');
        if (options?.tags !== undefined) {
            for (const tag of options.tags) {
                if (tag.startsWith(CHECKLY_IMPORT_FILENAME_TAG_PREFIX)) {
                    filename = tag.slice(CHECKLY_IMPORT_FILENAME_TAG_PREFIX.length);
                    break;
                }
            }
        }
        const [base, ext] = splitExt(filename);
        const parts = [parent];
        if (options?.isolate) {
            parts.push(base);
        }
        parts.push(filename);
        let candidate = node_path_1.default.join(...parts);
        do {
            let counter = this.#knownFilePaths.get(candidate) ?? 0;
            let satisfied = true;
            // If we wanted a unique match and this isn't the first time we've seen
            // the candidate, we're not satisfied.
            if (counter !== 0 && options?.unique) {
                satisfied = false;
            }
            // A content key attempts to differentiate between files based on a
            // representative value of their contents. If we've previously found
            // the candidate path but it had a different content key, we're
            // not satisfied, even if a unique match was not requested.
            if (options?.contentKey !== undefined) {
                const currentKey = this.#filePathContentKeys.get(candidate);
                if (currentKey !== undefined) {
                    if (currentKey !== options.contentKey) {
                        satisfied = false;
                    }
                }
                else {
                    this.#filePathContentKeys.set(candidate, options.contentKey);
                }
            }
            if (!satisfied || counter === 0) {
                counter += 1;
            }
            this.#knownFilePaths.set(candidate, counter);
            if (satisfied) {
                return new FilePath(candidate);
            }
            parts.pop();
            const nthBase = base + '-' + counter;
            if (options?.isolate) {
                parts.pop();
                parts.push(nthBase);
            }
            parts.push(nthBase + ext);
            candidate = node_path_1.default.join(...parts);
            // eslint-disable-next-line no-constant-condition
        } while (true);
    }
    importVariable(locator, file) {
        const reservedVariable = this.#reserveIdentifierForLocator(file.path, locator);
        file.namedImport(locator.id.value, locator.file.path, {
            relativeTo: (0, node_path_1.dirname)(file.path),
            alias: reservedVariable === locator.id ? undefined : reservedVariable.value,
        });
        return reservedVariable;
    }
    importFriendVariable(locator, file) {
        const reservedVariable = this.#reserveIdentifierForLocator(file.path, locator);
        file.namedImport(locator.id.value, locator.filePath, {
            relativeTo: (0, node_path_1.dirname)(file.path),
            alias: reservedVariable === locator.id ? undefined : reservedVariable.value,
        });
        return reservedVariable;
    }
    registerCheckGroup(physicalId, name, file) {
        const preferredId = new sourcegen_1.IdentifierValue(formatVariable('group', name));
        const locator = new GeneratedVariableLocator(preferredId, file);
        locator.id = this.#reserveIdentifierForLocator(file.path, locator);
        this.#checkGroupVariablesByPhysicalId.set(physicalId, locator);
        return locator;
    }
    lookupCheckGroup(physicalId) {
        const locator = this.#checkGroupVariablesByPhysicalId.get(physicalId);
        if (locator === undefined) {
            throw new MissingContextVariableMappingError();
        }
        return locator;
    }
    registerFriendCheckGroup(physicalId, friend) {
        const id = new sourcegen_1.IdentifierValue(friend.exportName);
        const locator = new FriendVariableLocator(id, friend.filePath);
        this.#checkGroupFriendVariablesByPhysicalId.set(physicalId, locator);
        return locator;
    }
    lookupFriendCheckGroup(physicalId) {
        const locator = this.#checkGroupFriendVariablesByPhysicalId.get(physicalId);
        if (locator === undefined) {
            throw new MissingContextVariableMappingError();
        }
        return locator;
    }
    registerAlertChannel(physicalId, name, file) {
        const preferredId = new sourcegen_1.IdentifierValue(formatVariable('alert', name));
        const locator = new GeneratedVariableLocator(preferredId, file);
        locator.id = this.#reserveIdentifierForLocator(file.path, locator);
        this.#alertChannelVariablesByPhysicalId.set(physicalId, locator);
        return locator;
    }
    lookupAlertChannel(physicalId) {
        const locator = this.#alertChannelVariablesByPhysicalId.get(physicalId);
        if (locator === undefined) {
            throw new MissingContextVariableMappingError();
        }
        return locator;
    }
    registerFriendAlertChannel(physicalId, friend) {
        const id = new sourcegen_1.IdentifierValue(friend.exportName);
        const locator = new FriendVariableLocator(id, friend.filePath);
        this.#alertChannelFriendVariablesByPhysicalId.set(physicalId, locator);
        return locator;
    }
    lookupFriendAlertChannel(physicalId) {
        const locator = this.#alertChannelFriendVariablesByPhysicalId.get(physicalId);
        if (locator === undefined) {
            throw new MissingContextVariableMappingError();
        }
        return locator;
    }
    registerPrivateLocation(physicalId, name, file) {
        const preferredId = new sourcegen_1.IdentifierValue(formatVariable('location', name));
        const locator = new GeneratedVariableLocator(preferredId, file);
        locator.id = this.#reserveIdentifierForLocator(file.path, locator);
        this.#privateLocationVariablesByPhysicalId.set(physicalId, locator);
        return locator;
    }
    lookupPrivateLocation(physicalId) {
        const locator = this.#privateLocationVariablesByPhysicalId.get(physicalId);
        if (locator === undefined) {
            throw new MissingContextVariableMappingError();
        }
        return locator;
    }
    registerFriendPrivateLocation(physicalId, friend) {
        const id = new sourcegen_1.IdentifierValue(friend.exportName);
        const locator = new FriendVariableLocator(id, friend.filePath);
        this.#privateLocationFriendVariablesByPhysicalId.set(physicalId, locator);
        return locator;
    }
    lookupFriendPrivateLocation(physicalId) {
        const locator = this.#privateLocationFriendVariablesByPhysicalId.get(physicalId);
        if (locator === undefined) {
            throw new MissingContextVariableMappingError();
        }
        return locator;
    }
    registerPrivateLocationGroupAssignment(privateLocationPhysicalId, groupPhysicalId) {
        const all = this.#checkGroupPrivateLocationPhysicalIdsByPhysicalId.get(groupPhysicalId) ?? [];
        all.push(privateLocationPhysicalId);
        this.#checkGroupPrivateLocationPhysicalIdsByPhysicalId.set(groupPhysicalId, all);
    }
    lookupCheckGroupPrivateLocations(groupPhysicalId) {
        const ids = this.#checkGroupPrivateLocationPhysicalIdsByPhysicalId.get(groupPhysicalId);
        if (ids === undefined) {
            throw new MissingContextVariableMappingError();
        }
        return ids;
    }
    registerPrivateLocationCheckAssignment(privateLocationPhysicalId, checkPhysicalId) {
        const all = this.#checkPrivateLocationPhysicalIdsByPhysicalId.get(checkPhysicalId) ?? [];
        all.push(privateLocationPhysicalId);
        this.#checkPrivateLocationPhysicalIdsByPhysicalId.set(checkPhysicalId, all);
    }
    lookupCheckPrivateLocations(checkPhysicalId) {
        const ids = this.#checkPrivateLocationPhysicalIdsByPhysicalId.get(checkPhysicalId);
        if (ids === undefined) {
            throw new MissingContextVariableMappingError();
        }
        return ids;
    }
    registerAlertChannelCheckSubscription(alertChannelPhysicalId, checkPhysicalId) {
        const all = this.#checkAlertChannelPhysicalIdsByPhysicalId.get(checkPhysicalId) ?? [];
        all.push(alertChannelPhysicalId);
        this.#checkAlertChannelPhysicalIdsByPhysicalId.set(checkPhysicalId, all);
    }
    lookupCheckAlertChannels(checkPhysicalId) {
        const ids = this.#checkAlertChannelPhysicalIdsByPhysicalId.get(checkPhysicalId);
        if (ids === undefined) {
            throw new MissingContextVariableMappingError();
        }
        return ids;
    }
    registerAlertChannelGroupSubscription(alertChannelPhysicalId, groupPhysicalId) {
        const all = this.#checkGroupAlertChannelPhysicalIdsByPhysicalId.get(groupPhysicalId) ?? [];
        all.push(alertChannelPhysicalId);
        this.#checkGroupAlertChannelPhysicalIdsByPhysicalId.set(groupPhysicalId, all);
    }
    lookupCheckGroupAlertChannels(groupPhysicalId) {
        const ids = this.#checkGroupAlertChannelPhysicalIdsByPhysicalId.get(groupPhysicalId);
        if (ids === undefined) {
            throw new MissingContextVariableMappingError();
        }
        return ids;
    }
    registerStatusPageService(physicalId, name, file) {
        const preferredId = new sourcegen_1.IdentifierValue(formatVariable('service', name));
        const locator = new GeneratedVariableLocator(preferredId, file);
        locator.id = this.#reserveIdentifierForLocator(file.path, locator);
        this.#statusPageServiceVariablesByPhysicalId.set(physicalId, locator);
        return locator;
    }
    lookupStatusPageService(physicalId) {
        const locator = this.#statusPageServiceVariablesByPhysicalId.get(physicalId);
        if (locator === undefined) {
            throw new MissingContextVariableMappingError();
        }
        return locator;
    }
    registerFriendStatusPageService(physicalId, friend) {
        const id = new sourcegen_1.IdentifierValue(friend.exportName);
        const locator = new FriendVariableLocator(id, friend.filePath);
        this.#statusPageServiceFriendVariablesByPhysicalId.set(physicalId, locator);
        return locator;
    }
    lookupFriendStatusPageService(physicalId) {
        const locator = this.#statusPageServiceFriendVariablesByPhysicalId.get(physicalId);
        if (locator === undefined) {
            throw new MissingContextVariableMappingError();
        }
        return locator;
    }
    registerKnownSecret(name) {
        if (this.#knownSecrets.has(name)) {
            return false;
        }
        this.#knownSecrets.add(name);
        return true;
    }
    registerAuxiliarySnippetFile(physicalId, snippetFile) {
        this.#auxiliarySnippetFilesByPhysicalId.set(physicalId, snippetFile);
        this.#auxiliarySnippetFilesByFilename.set(snippetFile.basename, snippetFile);
    }
    lookupAuxiliarySnippetFile(physicalId) {
        return this.#auxiliarySnippetFilesByPhysicalId.get(physicalId);
    }
    findScriptSnippetFiles(content) {
        const files = new Set();
        const filenames = (0, snippet_1.parseSnippetDependencies)(content);
        for (const filename of filenames) {
            const { name } = node_path_1.default.parse(filename);
            const candidates = [
                name,
                filename,
                `${name}.ts`,
                `${name}.js`,
                `${filename}.ts`,
                `${filename}.js`,
            ];
            for (const candidate of candidates) {
                const match = this.#auxiliarySnippetFilesByFilename.get(candidate);
                if (match !== undefined) {
                    files.add(match);
                    break;
                }
            }
        }
        return [...files];
    }
}
exports.Context = Context;
//# sourceMappingURL=context.js.map