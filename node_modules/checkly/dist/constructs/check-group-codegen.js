"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CheckGroupCodegen = exports.valueForCheckGroupFromId = void 0;
const codegen_1 = require("./internal/codegen");
const sourcegen_1 = require("../sourcegen");
const alert_escalation_policy_codegen_1 = require("./alert-escalation-policy-codegen");
const api_check_codegen_1 = require("./api-check-codegen");
const frequency_codegen_1 = require("./frequency-codegen");
const key_value_pair_codegen_1 = require("./key-value-pair-codegen");
const retry_strategy_codegen_1 = require("./retry-strategy-codegen");
const private_location_codegen_1 = require("./private-location-codegen");
const alert_channel_codegen_1 = require("./alert-channel-codegen");
function buildCheckGroupProps(program, genfile, builder, resource, context) {
    builder.string('name', resource.name);
    if (resource.activated !== undefined) {
        builder.boolean('activated', resource.activated);
    }
    if (resource.muted !== undefined) {
        builder.boolean('muted', resource.muted);
    }
    if (resource.runtimeId) {
        builder.string('runtimeId', resource.runtimeId);
    }
    if (resource.locations) {
        const locations = resource.locations;
        if (locations.length > 0) {
            builder.array('locations', builder => {
                for (const location of locations) {
                    builder.string(location);
                }
            });
        }
    }
    const privateLocationIds = (() => {
        try {
            return context.lookupCheckGroupPrivateLocations(resource.id);
        }
        catch {
            return;
        }
    })();
    if (privateLocationIds !== undefined) {
        builder.array('privateLocations', builder => {
            for (const privateLocationId of privateLocationIds) {
                try {
                    const privateLocationVariable = context.lookupPrivateLocation(privateLocationId);
                    const id = context.importVariable(privateLocationVariable, genfile);
                    builder.value(id);
                }
                catch {
                    try {
                        const privateLocationVariable = context.lookupFriendPrivateLocation(privateLocationId);
                        const id = context.importFriendVariable(privateLocationVariable, genfile);
                        builder.value(id);
                    }
                    catch {
                        builder.value((0, private_location_codegen_1.valueForPrivateLocationFromId)(genfile, privateLocationId));
                    }
                }
            }
        });
    }
    if (resource.tags) {
        const tags = resource.tags;
        if (tags.length > 0) {
            builder.array('tags', builder => {
                for (const tag of tags) {
                    builder.string(tag);
                }
            });
        }
    }
    if (resource.frequency !== undefined) {
        builder.value('frequency', (0, frequency_codegen_1.valueForFrequency)(genfile, resource.frequency));
    }
    if (resource.environmentVariables) {
        const variables = resource.environmentVariables;
        if (variables.length > 0) {
            builder.array('environmentVariables', builder => {
                for (const variable of variables) {
                    builder.value((0, key_value_pair_codegen_1.valueForKeyValuePair)(program, genfile, context, variable));
                }
            });
        }
    }
    const alertChannelIds = (() => {
        try {
            return context.lookupCheckGroupAlertChannels(resource.id);
        }
        catch {
            return;
        }
    })();
    if (alertChannelIds !== undefined) {
        builder.array('alertChannels', builder => {
            for (const alertChannelId of alertChannelIds) {
                try {
                    const alertChannelVariable = context.lookupAlertChannel(alertChannelId);
                    const id = context.importVariable(alertChannelVariable, genfile);
                    builder.value(id);
                }
                catch {
                    try {
                        const alertChannelVariable = context.lookupFriendAlertChannel(alertChannelId);
                        const id = context.importFriendVariable(alertChannelVariable, genfile);
                        builder.value(id);
                    }
                    catch {
                        builder.value((0, alert_channel_codegen_1.valueForAlertChannelFromId)(genfile, alertChannelId));
                    }
                }
            }
        });
    }
    if (resource.alertSettings) {
        builder.value('alertEscalationPolicy', (0, alert_escalation_policy_codegen_1.valueForAlertEscalation)(genfile, resource.alertSettings));
    }
    if (resource.browserChecks) {
        const config = resource.browserChecks;
        builder.object('browserChecks', builder => {
            if (Array.isArray(config.testMatch)) {
                builder.array('testMatch', builder => {
                    for (const match of config.testMatch) {
                        builder.string(match);
                    }
                });
            }
            else {
                builder.string('testMatch', config.testMatch);
            }
            // Only frequency is handled by the construct.
            if (config.frequency !== undefined) {
                builder.value('frequency', (0, frequency_codegen_1.valueForFrequency)(genfile, config.frequency));
            }
        });
    }
    if (resource.multiStepChecks) {
        const config = resource.multiStepChecks;
        builder.object('multiStepChecks', builder => {
            if (Array.isArray(config.testMatch)) {
                builder.array('testMatch', builder => {
                    for (const match of config.testMatch) {
                        builder.string(match);
                    }
                });
            }
            else {
                builder.string('testMatch', config.testMatch);
            }
            // Only frequency is handled by the construct.
            if (config.frequency !== undefined) {
                builder.value('frequency', (0, frequency_codegen_1.valueForFrequency)(genfile, config.frequency));
            }
        });
    }
    if (resource.localSetupScript) {
        builder.string('localSetupScript', resource.localSetupScript);
    }
    if (resource.localTearDownScript) {
        builder.string('localTearDownScript', resource.localTearDownScript);
    }
    if (resource.apiCheckDefaults) {
        const config = resource.apiCheckDefaults;
        const value = (0, sourcegen_1.object)(builder => {
            if (config.url) {
                builder.string('url', config.url);
            }
            if (config.headers) {
                const headers = config.headers;
                if (headers.length > 0) {
                    builder.array('headers', builder => {
                        for (const header of headers) {
                            builder.value((0, key_value_pair_codegen_1.valueForKeyValuePair)(program, genfile, context, header));
                        }
                    });
                }
            }
            if (config.queryParameters) {
                const params = config.queryParameters;
                if (params.length > 0) {
                    builder.array('queryParameters', builder => {
                        for (const param of params) {
                            builder.value((0, key_value_pair_codegen_1.valueForKeyValuePair)(program, genfile, context, param));
                        }
                    });
                }
            }
            if (config.basicAuth) {
                const basicAuth = config.basicAuth;
                if (basicAuth.username !== '' && basicAuth.password !== '') {
                    builder.object('basicAuth', builder => {
                        builder.string('username', basicAuth.username);
                        builder.string('password', basicAuth.password);
                    });
                }
            }
            if (config.assertions) {
                const assertions = config.assertions;
                if (assertions.length > 0) {
                    builder.array('assertions', builder => {
                        for (const assertion of assertions) {
                            builder.value((0, api_check_codegen_1.valueForAssertion)(genfile, assertion));
                        }
                    });
                }
            }
        });
        if (!value.isEmpty()) {
            builder.value('apiCheckDefaults', value);
        }
    }
    builder.value('retryStrategy', (0, retry_strategy_codegen_1.valueForRetryStrategy)(genfile, resource.retryStrategy));
    if (resource.runParallel !== undefined) {
        builder.boolean('runParallel', resource.runParallel);
    }
}
const construct = 'CheckGroup';
function valueForCheckGroupFromId(genfile, physicalId) {
    genfile.namedImport(construct, 'checkly/constructs');
    return (0, sourcegen_1.expr)((0, sourcegen_1.ident)(construct), builder => {
        builder.member((0, sourcegen_1.ident)('fromId'));
        builder.call(builder => {
            builder.number(physicalId);
        });
    });
}
exports.valueForCheckGroupFromId = valueForCheckGroupFromId;
class CheckGroupCodegen extends codegen_1.Codegen {
    validateSafety(resource) {
        if (resource.setupSnippetId) {
            throw new codegen_1.ImportSafetyViolation(`Conversion of Check Group setup/teardown snippets is not supported.`);
        }
        if (resource.tearDownSnippetId) {
            throw new codegen_1.ImportSafetyViolation(`Conversion of Check Group setup/teardown snippets is not supported.`);
        }
    }
    describe(resource) {
        return `Check Group: ${resource.name}`;
    }
    prepare(logicalId, resource, context) {
        this.validateSafety(resource);
        const filename = context.filePath('resources/check-group', resource.name, {
            isolate: true,
            unique: true,
        });
        context.registerCheckGroup(resource.id, resource.name, this.program.generatedConstructFile(filename.fullPath));
    }
    gencode(logicalId, resource, context) {
        this.validateSafety(resource);
        const { id, file } = context.lookupCheckGroup(resource.id);
        file.namedImport(construct, 'checkly/constructs');
        file.section((0, sourcegen_1.decl)(id, builder => {
            builder.variable((0, sourcegen_1.expr)((0, sourcegen_1.ident)(construct), builder => {
                builder.new(builder => {
                    builder.string(logicalId);
                    builder.object(builder => {
                        buildCheckGroupProps(this.program, file, builder, resource, context);
                    });
                });
            }));
            builder.export();
        }));
    }
}
exports.CheckGroupCodegen = CheckGroupCodegen;
//# sourceMappingURL=check-group-codegen.js.map