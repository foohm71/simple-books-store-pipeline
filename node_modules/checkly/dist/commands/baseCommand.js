"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseCommand = void 0;
const axios_1 = __importDefault(require("axios"));
const prompts_1 = __importDefault(require("prompts"));
const core_1 = require("@oclif/core");
const api_1 = require("../rest/api");
const command_style_1 = require("../helpers/command-style");
class BaseCommand extends core_1.Command {
    static coreCommand = false;
    static hidden = true;
    fancy = true;
    style = new command_style_1.CommandStyle(this);
    async init() {
        let version = process.env.CHECKLY_CLI_VERSION ?? this.config.version;
        // use latest version from NPM if it's running from the local environment or E2E
        if (version === '0.0.1-dev' || version?.startsWith('0.0.0')) {
            try {
                const { data: packageInformation } = await axios_1.default.get('https://registry.npmjs.org/checkly/latest');
                this.log(`\nNotice: replacing version '${version}' with latest '${packageInformation.version}'. If you wish to test with a different version, please pass the CHECKLY_CLI_VERSION environment variable.\n`);
                version = packageInformation.version;
            }
            catch { }
        }
        api_1.api.defaults.headers['x-checkly-cli-version'] = version;
        // This overrides prompts answers/selections (used on E2E tests)
        if (process.env.CHECKLY_E2E_PROMPTS_INJECTIONS) {
            try {
                const injections = JSON.parse(process.env.CHECKLY_E2E_PROMPTS_INJECTIONS);
                prompts_1.default.inject(injections);
            }
            catch {
                process.stderr.write('Error parsing CHECKLY_E2E_PROMPTS_INJECTIONS environment variable for injections.');
            }
        }
        if (process.env.CHECKLY_E2E_DISABLE_FANCY_OUTPUT) {
            this.fancy = false;
        }
        return super.init();
    }
    async run() {
        await this.exit(0);
    }
    catch(err) {
        // TODO: we can add Sentry here and log critical errors.
        return super.catch(err);
    }
}
exports.BaseCommand = BaseCommand;
//# sourceMappingURL=baseCommand.js.map