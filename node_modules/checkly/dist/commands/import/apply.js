"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.performApplyAction = exports.confirmApply = void 0;
const core_1 = require("@oclif/core");
const prompts_1 = __importDefault(require("prompts"));
const log_symbols_1 = __importDefault(require("log-symbols"));
const chalk_1 = __importDefault(require("chalk"));
const api = __importStar(require("../../rest/api"));
const authCommand_1 = require("../authCommand");
const common_messages_1 = __importDefault(require("../../messages/common-messages"));
const util_1 = require("../../services/util");
const checkly_config_loader_1 = require("../../services/checkly-config-loader");
const commit_1 = require("./commit");
class ImportApplyCommand extends authCommand_1.AuthCommand {
    static hidden = false;
    static description = 'Attach imported resources into your project in a pending state.';
    static flags = {
        config: core_1.Flags.string({
            char: 'c',
            description: common_messages_1.default.configFile,
        }),
    };
    async run() {
        const { flags } = await this.parse(ImportApplyCommand);
        const { config: configFilename, } = flags;
        const { configDirectory, configFilenames } = (0, util_1.splitConfigFilePath)(configFilename);
        const { config: checklyConfig, } = await (0, checkly_config_loader_1.loadChecklyConfig)(configDirectory, configFilenames);
        const { logicalId, } = checklyConfig;
        const { data: unappliedPlans } = await api.projects.findImportPlans(logicalId, {
            onlyUnapplied: true,
        });
        if (unappliedPlans.length === 0) {
            this.style.fatal(`No plans available to apply.`);
            return;
        }
        const plan = await this.#selectPlan(unappliedPlans);
        await performApplyAction.call(this, plan);
        const commit = await commit_1.confirmCommit.call(this);
        if (!commit) {
            return;
        }
        await commit_1.performCommitAction.call(this, plan);
    }
    async #selectPlan(plans) {
        const choices = plans.map((plan, index) => ({
            title: `Plan #${index + 1} from ${new Date(plan.createdAt)}`,
            value: plan.id,
            description: `ID: ${plan.id}`,
        }));
        choices.unshift({
            title: 'Exit without applying',
            value: 'exit',
            description: 'No changes will be made.',
        });
        const plansById = plans.reduce((m, plan) => m.set(plan.id, plan), new Map());
        const { planId } = await (0, prompts_1.default)({
            name: 'planId',
            type: 'select',
            message: `Found ${plans.length} unapplied plan(s). Which one to apply?`,
            choices,
        });
        this.log();
        if (planId === 'exit' || planId === undefined) {
            this.log('Exiting without making any changes.');
            this.exit(0);
        }
        const plan = plansById.get(planId);
        if (plan === undefined) {
            throw new Error('Bug: plan ID missing from plan map');
        }
        return plan;
    }
}
exports.default = ImportApplyCommand;
async function confirmApply() {
    const { apply } = await (0, prompts_1.default)({
        name: 'apply',
        type: 'confirm',
        message: 'Would you like to apply the plan now?',
    });
    this.log();
    if (apply) {
        return true;
    }
    this.log(`\
  To apply your plan at a later time, please run:

    ${chalk_1.default.green('npx checkly import apply')}

  To cancel the plan, run:

    ${chalk_1.default.green('npx checkly import cancel')}
`);
    return false;
}
exports.confirmApply = confirmApply;
async function performApplyAction(plan) {
    this.style.actionStart('Applying plan');
    try {
        await api.projects.applyImportPlan(plan.id);
        this.style.actionSuccess();
    }
    catch (err) {
        this.style.actionFailure();
        throw err;
    }
    this.log(`${log_symbols_1.default.success} ${chalk_1.default.bold('Your import plan has been applied!')}`);
    this.log();
    this.log(`\
  The code generated for the import plan is now linked to the underlying
  resources. If you deploy now, you are modifying the actual resources. You
  may still cancel the plan but any changes you've deployed cannot be undone.

  ${log_symbols_1.default.info} \
${chalk_1.default.cyan('For safety, resources are not deletable until the plan has been committed.')}

  The final step will be to commit your plan, at which point the underlying
  resources will be fully managed by the Checkly CLI in the exact same
  manner as any other CLI-native resource.

  If there is any risk that a different user or a CI workflow may deploy a
  different version of this Checkly project before the imported resources can
  be merged to your codebase, you should hold off committing the plan until
  the merge is completed.

  ${log_symbols_1.default.warning} \
${chalk_1.default.yellow('The plan cannot be cancelled after it has been committed.')}
`);
}
exports.performApplyAction = performApplyAction;
//# sourceMappingURL=apply.js.map