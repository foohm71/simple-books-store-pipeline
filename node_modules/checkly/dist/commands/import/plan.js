"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const promises_1 = __importDefault(require("node:fs/promises"));
const node_path_1 = __importDefault(require("node:path"));
const promises_2 = require("node:timers/promises");
const core_1 = require("@oclif/core");
const prompts_1 = __importDefault(require("prompts"));
const chalk_1 = __importDefault(require("chalk"));
const axios_1 = require("axios");
const log_symbols_1 = __importDefault(require("log-symbols"));
const uuid_1 = require("uuid");
const api = __importStar(require("../../rest/api"));
const authCommand_1 = require("../authCommand");
const common_messages_1 = __importDefault(require("../../messages/common-messages"));
const util_1 = require("../../services/util");
const checkly_config_loader_1 = require("../../services/checkly-config-loader");
const projects_1 = require("../../rest/projects");
const sourcegen_1 = require("../../sourcegen");
const construct_codegen_1 = require("../../constructs/construct-codegen");
const codegen_1 = require("../../constructs/internal/codegen");
const snippet_1 = require("../../constructs/internal/codegen/snippet");
const errors_1 = require("@oclif/core/errors");
const commit_1 = require("./commit");
const apply_1 = require("./apply");
const checkly_config_codegen_1 = require("../../services/checkly-config-codegen");
const resolver_1 = require("../../services/check-parser/package-files/resolver");
const package_json_file_1 = require("../../services/check-parser/package-files/package-json-file");
const package_manager_1 = require("../../services/check-parser/package-files/package-manager");
const project_parser_1 = require("../../services/project-parser");
const config_1 = __importDefault(require("../../services/config"));
const project_1 = require("../../constructs/project");
class ImportPlanCommand extends authCommand_1.AuthCommand {
    static hidden = false;
    static description = `\
Import existing resources from your Checkly account to your project.

By default, all resources that can be imported will be imported. However, you
may fine-tune the process by including or excluding any combination of
resources.

The import process consists of three steps:

1. Creating a plan, which generates the appropriate code for your resources
2. Applying the plan, which links your resources to the generated code
3. Committing the plan, which finalizes the import session

CREATING A PLAN

Creating a plan carries no risk as no concrete links to your Checkly resources
are made at this point. However, if you accidentally deploy the generated code
before applying the plan, you will end up with duplicate resources and will
not be able to complete the import session without first deleting the
duplicates.

For the curious, you may also preview the generated code with the '--preview'
option. No plan will be created, allowing you to leisurely inspect the
generated code. However keep in mind that you will need to create a plan to
actually import any resources, at which point the code will be generated
again.

You may cancel any plan you've created without affecting any of the
underlying resources.

APPLYING A PLAN

Applying a plan links your existing resources to the generated code. You
should carefully review the generated code to make sure that it contains the
resources you expect before applying a plan. After a plan has been applied,
any deployments of those resources will irreversibly modify the underlying
Checkly resources. However, as a fail safe against concurrent use, any
deployments not including the imported resources will not delete the
underlying resources (or the links to the resources). This means that there
is no need to block deployments while working on an import session.

Even after you've applied a plan, you may still cancel it, which will unlink
the underlying resources from your project once more. However, keep in mind
that any changes to the resources that you've already deployed cannot be
undone.

COMMITTING A PLAN

Finally, committing a plan removes all fail safes and permanently links the
imported resources to your project. Any resources you remove from your code
will result in the underlying resources also getting irrevocably deleted on
the next deploy. You should only commit your plan once you are sure that all
future deployments include the imported resources.`;
    static flags = {
        config: core_1.Flags.string({
            char: 'c',
            description: common_messages_1.default.configFile,
        }),
        root: core_1.Flags.string({
            description: 'The root folder in which to write generated code files.',
            default: '__checks__',
        }),
        preview: core_1.Flags.boolean({
            description: 'Preview generated code without creating an actual import plan.',
            default: false,
        }),
        'debug-import-plan': core_1.Flags.boolean({
            description: 'Output the import plan to a file.',
            default: false,
            hidden: true,
        }),
        'debug-import-plan-output-file': core_1.Flags.string({
            description: 'The file to output the import plan to.',
            default: './debug-import-plan.json',
            hidden: true,
        }),
    };
    static args = {
        resource: core_1.Args.string({
            name: 'resource',
            required: false,
            description: 'A specific resource to import.',
        }),
    };
    static strict = false;
    static hiddenAliases = [
        'import',
    ];
    async run() {
        const { flags, argv } = await this.parse(ImportPlanCommand);
        const { config: configFilename, root: rootDirectory, 'debug-import-plan': debugImportPlan, 'debug-import-plan-output-file': debugImportPlanOutputFile, preview, } = flags;
        const filters = argv.map(value => {
            return parseFilter(value);
        });
        this.style.shortInfo(`You are about to import resources from your Checkly account.`);
        this.style.comment(`Please make sure to commit any unsaved changes to avoid having any ` +
            `local changes get overwritten by generated code.`);
        const { configDirectory, configFilenames } = (0, util_1.splitConfigFilePath)(configFilename);
        const checklyConfig = await this.#loadConfig(configDirectory, configFilenames)
            ?? await this.#interactiveCreateConfig(configDirectory);
        await this.#initializeProject(checklyConfig);
        const constructExports = await this.#findExportedResources(configDirectory, checklyConfig, rootDirectory);
        const friendExports = {
            'alert-channel': new Map(),
            'check-group': new Map(),
            'private-location': new Map(),
            'status-page-service': new Map(),
        };
        const friends = [];
        for (const constructExport of constructExports) {
            const { type, logicalId } = constructExport;
            const friendExport = friendExports[type];
            if (friendExport === undefined) {
                continue;
            }
            friendExport.set(logicalId, constructExport);
            friends.push({
                type,
                logicalId,
            });
        }
        const { logicalId, } = checklyConfig;
        if (!preview) {
            const { data: existingPlans } = await api.projects.findImportPlans(logicalId, {
                onlyUncommitted: true,
            });
            if (existingPlans.length !== 0) {
                await this.#handleExistingPlans(existingPlans);
            }
        }
        const createProgram = () => {
            return new sourcegen_1.Program({
                rootDirectory,
                constructFileSuffix: '.check',
                constructHeaders: preview ? [previewComment()] : undefined,
                specFileSuffix: '.spec',
                language: 'typescript',
            });
        };
        // These are needed for the interactive filter creation for now. Ideally
        // we'd remove these.
        const program = createProgram();
        const codegen = new construct_codegen_1.ConstructCodegen(program);
        // If the user provided no filter, ask interactively.
        if (filters.length === 0) {
            filters.push(...await this.#interactiveFilter(logicalId, codegen));
        }
        // Inject the default filter.
        //
        // By default all resource will be included, unless the user has specified
        // an inclusive filter by themselves, in which case the default filter
        // excludes all resources.
        filters.unshift({
            type: filters.some(({ type }) => type === 'include') ? 'exclude' : 'include',
        });
        while (true) {
            // Recreate program on every attempt as otherwise resources from earlier
            // runs will persist.
            const program = createProgram();
            const codegen = new construct_codegen_1.ConstructCodegen(program);
            const plan = await this.#createImportPlan(logicalId, {
                preview,
                filters,
                friends,
            });
            if (!plan) {
                return;
            }
            if (debugImportPlan) {
                const output = JSON.stringify(plan, null, 2);
                await promises_1.default.writeFile(debugImportPlanOutputFile, output, 'utf8');
                this.style.shortSuccess(`Successfully wrote debug import plan to "${debugImportPlanOutputFile}".`);
                return;
            }
            try {
                const { failures } = this.#generateCode(plan, program, codegen, friendExports);
                if (failures.length) {
                    this.log(`${log_symbols_1.default.error} ${chalk_1.default.red('The following resources could not be imported:')}`);
                    this.log();
                    for (const { resource, cause } of failures) {
                        const spec = `${resource.type}:${resource.physicalId}`;
                        const desc = (() => {
                            try {
                                return codegen.describe(resource);
                            }
                            catch {
                                return resource.type;
                            }
                        })();
                        this.log(`  ${desc} (${chalk_1.default.gray(spec)})`);
                        this.log();
                        this.log(`    ${chalk_1.default.red(cause.toString())}`);
                        this.log();
                        // Proactively exclude the failed resource. If the user wants to
                        // retry it'll already be in the filter list, and otherwise it will
                        // simply not get used.
                        filters.push({
                            type: 'exclude',
                            resource: {
                                type: resource.type,
                                physicalId: resource.physicalId,
                            },
                        });
                    }
                    const retry = await this.#confirmRetryWithoutFailed();
                    if (!retry) {
                        this.cancelAndExit();
                    }
                    // When previewing, there is no plan to cancel.
                    if (preview) {
                        continue;
                    }
                    this.style.comment(`The current plan will be cancelled so that a new plan can be created.`);
                    this.style.actionStart('Cancelling current plan');
                    try {
                        await api.projects.cancelImportPlan(plan.id);
                        this.style.actionSuccess();
                    }
                    catch (err) {
                        this.style.actionFailure();
                        throw err;
                    }
                    this.style.comment(`A new plan will be created without the failed resources.`);
                    continue;
                }
                this.style.actionStart('Writing files');
                try {
                    await program.realize();
                    this.style.actionSuccess();
                }
                catch (err) {
                    this.style.actionFailure();
                    throw err;
                }
                this.log(`${log_symbols_1.default.success} ${chalk_1.default.bold('Your import plan has been created!')}`);
                this.log();
                this.log(`  You can find the generated code under the following directory:`);
                this.log();
                this.log(`    ${chalk_1.default.green(rootDirectory)}`);
                this.log();
                this.log(`\
  The imported resources have not been linked to your project yet. Please
  make sure to inspect the generated code. Should you find anything you do
  not like, you can cancel the import plan and no harm will be done.

  ${log_symbols_1.default.warning} \
${chalk_1.default.yellow('If you deploy now, you will end up with duplicate resources!')}

  Once you have inspected the code, the next step will be to apply the plan,
  which links the generated code to the underlying resources, making them
  modifiable. At this point you may still cancel the plan, though any changes
  you've already deployed cannot be undone.

  ${log_symbols_1.default.info} \
${chalk_1.default.cyan('For safety, resources are not deletable until the plan has been committed.')}

  The final step will be to commit your plan, at which point the underlying
  resources will be fully managed by the Checkly CLI in the exact same
  manner as any other CLI-native resource.
`);
                const apply = await apply_1.confirmApply.call(this);
                if (!apply) {
                    return;
                }
                await apply_1.performApplyAction.call(this, plan);
                const commit = await commit_1.confirmCommit.call(this);
                if (!commit) {
                    return;
                }
                await commit_1.performCommitAction.call(this, plan);
                return;
            }
            catch (err) {
                if (err instanceof errors_1.ExitError) {
                    throw err;
                }
                try {
                    const output = JSON.stringify(plan, null, 2);
                    await promises_1.default.writeFile(debugImportPlanOutputFile, output, 'utf8');
                    this.log(`${log_symbols_1.default.warning} Please contact Checkly support at support@checklyhq.com and attach the newly created "${debugImportPlanOutputFile}" file.`);
                    // eslint-disable-next-line @typescript-eslint/no-unused-vars
                }
                catch (err) {
                    this.log(`${log_symbols_1.default.warning} Please contact Checkly support at support@checklyhq.com.`);
                }
                throw err;
            }
        }
    }
    #outputConfigSection(options) {
        const { title, step: [step, totalSteps], description } = options;
        this.log(`  ${title} ${chalk_1.default.grey(`(step ${step}/${totalSteps})`)}`);
        this.log();
        this.style.comment(description);
    }
    async #askProjectName(step) {
        this.#outputConfigSection({
            title: `Let's give your project a name`,
            description: `You'll be able to change the name later if you like.`,
            step,
        });
        while (true) {
            const { projectName } = await (0, prompts_1.default)({
                name: 'projectName',
                type: 'text',
                message: 'What should we call your project?',
            });
            this.log();
            if (projectName === undefined) {
                this.cancelAndExit();
            }
            if (projectName.trim() !== '') {
                return projectName;
            }
            this.style.comment(`Sorry, but a project name is absolutely required. ` +
                `You can also press ESC to cancel and exit.`);
        }
    }
    async #askLogicalId(suggested, step) {
        this.#outputConfigSection({
            title: `Set up a unique project identifier`,
            description: `The identifier given here uniquely identifies your ` +
                `project among any other Checkly projects you may have. You will ` +
                `not be able to change the identifier later without recreating the ` +
                `project. Please choose a value you'll be comfortable with ` +
                `long term.`,
            step,
        });
        while (true) {
            const { logicalId } = await (0, prompts_1.default)({
                name: 'logicalId',
                type: 'text',
                message: 'How would you like your project to be identified?',
                initial: suggested,
                validate: (input) => {
                    if (!/^[A-Za-z0-9_\-/#.]+$/.test(input)) {
                        return `Please only use ASCII letters, numbers, and the ` +
                            `symbols _, -, /, #, and .`;
                    }
                    return true;
                },
            });
            this.log();
            if (logicalId === undefined) {
                this.cancelAndExit();
            }
            if (logicalId.trim() !== '') {
                return logicalId;
            }
            this.style.comment(`Sorry, but a project identifier is absolutely required. ` +
                `You can also press ESC to cancel and exit.`);
        }
    }
    async #interactiveCreateConfig(configDirectory) {
        this.style.shortWarning(`Unable to find an existing Checkly configuration file.`);
        this.style.comment(`Setting up Checkly for the first time? No worries, we'll walk you ` +
            `through the process.`);
        const choices = [{
                title: `Yes, I want to start a new project for the imported resources`,
                value: 'init',
                description: `We'll walk you through a minimal setup`,
            }, {
                title: `No, I intended to import resources into an existing project`,
                value: 'mistake',
                description: 'Exit and verify your configuration.',
            }, {
                title: 'No, I want to cancel and exit',
                value: 'exit',
                description: 'No changes will be made.',
            }];
        const { action } = await (0, prompts_1.default)({
            name: 'action',
            type: 'select',
            message: 'Set up a new Checkly project?',
            choices,
        });
        this.log();
        switch (action) {
            case 'init': {
                const projectName = await this.#askProjectName([1, 2]);
                const suggestedLogicalId = (0, sourcegen_1.cased)(projectName, 'kebab-case');
                const logicalId = await this.#askLogicalId(suggestedLogicalId, [2, 2]);
                try {
                    this.style.actionStart('Creating project');
                    try {
                        await api.projects.create({
                            name: projectName,
                            logicalId,
                        });
                    }
                    catch (err) {
                        if ((0, axios_1.isAxiosError)(err)) {
                            if (err.response?.status === 409) {
                                throw new Error(`You are already using the same identifier for a different project.`);
                            }
                        }
                        throw err;
                    }
                    this.style.actionSuccess();
                }
                catch (err) {
                    this.style.actionFailure();
                    throw err;
                }
                const program = new sourcegen_1.Program({
                    rootDirectory: configDirectory,
                    constructFileSuffix: '.check',
                    specFileSuffix: '.spec',
                    language: 'typescript',
                });
                const context = new codegen_1.Context();
                const config = {
                    projectName,
                    logicalId,
                    checks: {
                        tags: ['mac'],
                        checkMatch: '**/__checks__/**/*.check.ts',
                    },
                };
                try {
                    this.style.actionStart('Creating Checkly configuration');
                    // TODO: Make this less ugly.
                    (0, checkly_config_codegen_1.generateChecklyConfig)(program, context, config, 'checkly.config.ts');
                    this.style.actionSuccess();
                }
                catch (err) {
                    this.style.actionFailure();
                    throw err;
                }
                let askInstall = false;
                let packageJson;
                try {
                    this.style.actionStart('Configuring package.json for Checkly');
                    // TODO: Make this less ugly.
                    packageJson = (() => {
                        const file = this.#loadPackageJson();
                        if (file !== undefined) {
                            this.style.shortSuccess(`Found existing package.json`);
                            return file;
                        }
                        else {
                            this.style.shortSuccess(`Creating a new minimal package.json`);
                            return this.#createPackageJson(logicalId);
                        }
                    })();
                    const updated = packageJson.upsertDevDependencies({
                        checkly: `^5`,
                        jiti: '^2',
                    });
                    if (updated) {
                        this.style.shortSuccess(`Successfully added Checkly devDependencies`);
                        program.staticSupportFile(packageJson.meta.filePath, packageJson.toJSON());
                        askInstall = true;
                    }
                    else {
                        this.style.shortSuccess(`Checkly devDependencies are already up to date`);
                    }
                    this.style.actionSuccess();
                }
                catch (err) {
                    this.style.actionFailure();
                    throw err;
                }
                try {
                    this.style.actionStart('Writing project files');
                    await program.realize();
                    this.style.actionSuccess();
                }
                catch (err) {
                    this.style.actionFailure();
                    throw err;
                }
                if (askInstall && packageJson !== undefined) {
                    await this.#interactiveNpmInstall(packageJson.meta.dirname);
                }
                return config;
            }
            case 'mistake':
                this.style.fatal(`Please verify your configuration and try again.`);
                this.cancelAndExit();
                break;
            case 'exit':
            // falls through
            default: {
                this.cancelAndExit();
            }
        }
    }
    #loadPackageJson() {
        const resolver = new resolver_1.PackageFilesResolver();
        return resolver.loadPackageJsonFile(process.cwd(), {
            isDir: true,
        });
    }
    #createPackageJson(logicalId) {
        return package_json_file_1.PackageJsonFile.make(package_json_file_1.PackageJsonFile.FILENAME, {
            name: logicalId,
            version: '1.0.0',
            private: true,
        });
    }
    async #interactiveNpmInstall(dirPath, forcePackageManager) {
        const { execa } = await import('execa');
        const packageManager = forcePackageManager ?? await (async () => {
            try {
                this.style.actionStart(`Detecting package manager`);
                const packageManager = await (0, package_manager_1.detectPackageManager)(dirPath);
                this.style.actionSuccess();
                this.style.comment(`It looks like your package manager is ${packageManager.name}.`);
                return packageManager;
            }
            catch (err) {
                this.style.actionFailure();
                throw err;
            }
        })();
        const { unsafeDisplayCommand, executable, args } = packageManager.installCommand();
        const choices = [{
                title: `Yes, please run \`${unsafeDisplayCommand}\` for me`,
                value: 'install',
            }, {
                title: `I want to use a different package manager`,
                value: 'other-manager',
            }, {
                title: 'I will do it later myself',
                value: 'later',
            }];
        const { action } = await (0, prompts_1.default)({
            type: 'select',
            name: 'action',
            message: 'Would you like to install dependencies now? (recommended)',
            choices,
        });
        this.log();
        switch (action) {
            case 'install': {
                this.style.comment(`Ok, now running \`${unsafeDisplayCommand}\`.`);
                try {
                    await execa(executable, args, {
                        cwd: dirPath,
                        stdout: ['inherit'],
                        stderr: ['inherit'],
                        stdin: ['inherit'],
                    });
                    this.log();
                    this.style.comment(`Successfully installed dependencies.`);
                }
                catch (err) {
                    if (err instanceof Error) {
                        this.style.longError(`Failed to install dependencies`, err.message); // TODO :
                    }
                    this.style.comment(`Uh oh. Looks like that didn't quite work as expected.` +
                        `\n\n` +
                        `You can still continue the import process and install ` +
                        `dependencies later by yourself.`);
                    const { action } = await (0, prompts_1.default)({
                        type: 'confirm',
                        name: 'action',
                        message: 'Continue the import process?',
                    });
                    this.log();
                    if (action) {
                        this.style.comment(`Great, let's proceed to the next step.`);
                        await (0, promises_2.setTimeout)(200);
                    }
                    else {
                        this.cancelAndExit();
                    }
                }
                break;
            }
            case 'other-manager': {
                const packageManagersByName = Object.fromEntries(package_manager_1.knownPackageManagers.map(packageManager => {
                    return [packageManager.name, packageManager];
                }));
                const choices = package_manager_1.knownPackageManagers.map(packageManager => ({
                    title: packageManager.name,
                    value: packageManager.name,
                }));
                choices.push({
                    title: 'None of the above',
                    value: 'other',
                });
                const { action } = await (0, prompts_1.default)({
                    type: 'select',
                    name: 'action',
                    message: 'Which package manager would you like to use?',
                    choices,
                });
                this.log();
                if (action === undefined) {
                    this.cancelAndExit();
                }
                if (action === 'other') {
                    this.style.comment(`Alright. If possible, let us know which package manager you ` +
                        `use and we may be able to support it in the future.` +
                        `\n\n` +
                        `You can still continue the import process and install ` +
                        `dependencies later by yourself.`);
                    const { action } = await (0, prompts_1.default)({
                        type: 'confirm',
                        name: 'action',
                        message: 'Continue the import process?',
                    });
                    this.log();
                    if (action) {
                        this.style.comment(`Great, let's proceed to the next step.`);
                        await (0, promises_2.setTimeout)(200);
                        break;
                    }
                    else {
                        this.cancelAndExit();
                    }
                }
                const packageManager = packageManagersByName[action];
                if (packageManager === undefined) {
                    throw new Error(`Somehow, you selected an option that does not exist.`);
                }
                return this.#interactiveNpmInstall(dirPath, packageManager);
            }
            case 'later': {
                this.style.comment(`Ok, but make sure to perform the appropriate actions to install ` +
                    `dependencies once you've completed the setup.` +
                    `\n\n` +
                    `If you do not, the Checkly CLI will not function as intended.`);
                await (0, promises_2.setTimeout)(200);
                break;
            }
            default: {
                this.cancelAndExit();
            }
        }
    }
    async #loadConfig(configDirectory, configFilenames) {
        try {
            const { config: checklyConfig, } = await (0, checkly_config_loader_1.loadChecklyConfig)(configDirectory, configFilenames);
            return checklyConfig;
        }
        catch (err) {
            if (err instanceof checkly_config_loader_1.ConfigNotFoundError) {
                return;
            }
            throw err;
        }
    }
    async #findExportedResources(configDirectory, checklyConfig, rootDirectory) {
        this.style.actionStart('Parsing your project for exported resources');
        try {
            const { data: account } = await api.accounts.get(config_1.default.getAccountId());
            const { data: availableRuntimes } = await api.runtimes.getAll();
            await (0, project_parser_1.parseProject)({
                directory: configDirectory,
                projectLogicalId: checklyConfig.logicalId,
                projectName: checklyConfig.projectName,
                repoUrl: checklyConfig.repoUrl,
                checkMatch: checklyConfig.checks?.checkMatch,
                browserCheckMatch: checklyConfig.checks?.browserChecks?.testMatch,
                multiStepCheckMatch: checklyConfig.checks?.multiStepChecks?.testMatch,
                ignoreDirectoriesMatch: checklyConfig.checks?.ignoreDirectoriesMatch,
                checkDefaults: checklyConfig.checks,
                browserCheckDefaults: checklyConfig.checks?.browserChecks,
                availableRuntimes: availableRuntimes.reduce((acc, runtime) => {
                    acc[runtime.name] = runtime;
                    return acc;
                }, {}),
                defaultRuntimeId: account.runtimeId,
                verifyRuntimeDependencies: false,
            });
            this.style.actionSuccess();
            const constructExports = project_1.Session.constructExports;
            switch (constructExports.length) {
                case 0: {
                    this.style.comment(`Did not find any exported resources.`);
                    break;
                }
                case 1: {
                    this.style.comment(`Found 1 exported resource.`);
                    break;
                }
                default: {
                    this.style.comment(`Found ${constructExports.length} exported resources.`);
                    break;
                }
            }
            // Paths need to be relative to the root directory or our generated
            // imports won't work correctly.
            for (const constructExport of constructExports) {
                constructExport.filePath = node_path_1.default.relative(rootDirectory, constructExport.filePath);
            }
            return constructExports;
        }
        catch (err) {
            this.style.actionFailure();
            throw err;
        }
    }
    async #confirmRetryWithoutFailed() {
        const { action } = await (0, prompts_1.default)({
            name: 'action',
            type: 'confirm',
            message: 'Would you like to try again without the failed resources?',
        });
        this.log();
        return action ?? false;
    }
    async #createImportPlan(logicalId, options) {
        this.style.actionStart('Creating a new plan');
        try {
            const { data } = await api.projects.createImportPlan(logicalId, options);
            this.style.actionSuccess();
            return data;
        }
        catch (err) {
            this.style.actionFailure();
            if ((0, axios_1.isAxiosError)(err)) {
                if (err.response?.status === 404) {
                    const message = err.response?.data.message;
                    if (message) {
                        this.style.fatal(message);
                        return;
                    }
                }
            }
            throw err;
        }
    }
    async #interactiveFilter(logicalId, codegen) {
        const choices = [{
                title: `I want to import everything in one go`,
                value: 'all',
            }, {
                title: `Let me choose resources manually`,
                value: 'choose',
                description: 'You will be presented with options.'
            }, {
                title: 'Cancel and exit',
                value: 'exit',
                description: 'No changes will be made.',
            }];
        const { action } = await (0, prompts_1.default)({
            name: 'action',
            type: 'select',
            message: 'Which resources would you like to import?',
            choices,
        });
        this.log();
        switch (action) {
            case 'all':
                return [];
            case 'choose': {
                const choices = await (async () => {
                    this.style.actionStart('Fetching available resources');
                    try {
                        const { data } = await api.projects.createImportPlan(logicalId, {
                            preview: true,
                            filters: [{
                                    type: 'include',
                                }],
                        });
                        this.style.actionSuccess();
                        return (data.changes?.resources ?? []).flatMap(resource => {
                            if (!isFilterable(resource.type)) {
                                return [];
                            }
                            try {
                                return [{
                                        title: codegen.describe(resource),
                                        value: `${resource.type}:${resource.physicalId}`,
                                        description: `${resource.type}:${resource.physicalId}`,
                                    }];
                            }
                            catch {
                                return [];
                            }
                        });
                    }
                    catch (err) {
                        this.style.actionFailure();
                        if ((0, axios_1.isAxiosError)(err)) {
                            if (err.response?.status === 404) {
                                return [];
                            }
                        }
                        throw err;
                    }
                })();
                choices.sort((a, b) => {
                    return a.title.localeCompare(b.title);
                });
                const { resources } = await (0, prompts_1.default)({
                    name: 'resources',
                    type: 'autocompleteMultiselect',
                    message: 'Please select the resources you would like to import',
                    choices,
                    hint: ' - Space to select. Return to submit.',
                    instructions: false,
                });
                this.log();
                if (resources === undefined) {
                    this.cancelAndExit();
                }
                if (resources.length === 0) {
                    this.style.fatal(`You did not choose any resources.`);
                    this.cancelAndExit();
                }
                return resources.map(parseFilter);
            }
            case 'exit':
            // falls through
            default: {
                this.cancelAndExit();
            }
        }
    }
    #generateCode(plan, program, codegen, friendExports) {
        this.style.actionStart('Generating Checkly constructs for imported resources');
        try {
            const context = new codegen_1.Context();
            const failures = new Map();
            if (plan.changes) {
                const { resources, friends, auxiliary } = plan.changes;
                if (friends) {
                    for (const resource of friends) {
                        try {
                            if (friendExports[resource.type] === undefined) {
                                throw new Error(`Unable to process unsupported friend resource type '${resource.type}'.`);
                            }
                            const friendExport = friendExports[resource.type].get(resource.logicalId);
                            if (friendExport === undefined) {
                                throw new Error(`Received friend resource '${resource.logicalId}' that was not requested for.`);
                            }
                            switch (resource.type) {
                                case 'alert-channel':
                                    context.registerFriendAlertChannel(resource.physicalId, friendExport);
                                    break;
                                case 'check-group':
                                    context.registerFriendCheckGroup(resource.physicalId, friendExport);
                                    break;
                                case 'private-location':
                                    context.registerFriendPrivateLocation(resource.physicalId, friendExport);
                                    break;
                                case 'status-page-service':
                                    context.registerFriendStatusPageService(resource.physicalId, friendExport);
                                    break;
                            }
                        }
                        catch (cause) {
                            throw new Error(`Failed to process friend resource '${resource.type}:${resource.physicalId}' (${resource.logicalId}): ${cause}`, { cause });
                        }
                    }
                }
                if (auxiliary) {
                    const globalSnippetFiles = new Set();
                    for (const resource of auxiliary) {
                        try {
                            switch (resource.type) {
                                case 'snippet': {
                                    const snippet = resource.payload;
                                    if (!(0, snippet_1.isSnippet)(snippet)) {
                                        throw new Error(`Invalid auxiliary snippet`);
                                    }
                                    const snippetFilePath = context.filePath('snippets', snippet.name, {
                                        unique: false,
                                        contentKey: `snippet::${snippet.id}`,
                                        case: (0, snippet_1.isSafeSnippetFilename)(snippet.name) ? 'identity' : 'kebab-case',
                                    });
                                    const snippetFile = program.staticSupportFile(snippetFilePath.fullPath, snippet.script);
                                    globalSnippetFiles.add(snippetFile);
                                    context.registerAuxiliarySnippetFile(snippet.id, snippetFile);
                                    break;
                                }
                                default:
                                    throw new Error(`Unable to process unsupported auxiliary resource type '${resource.type}'.`);
                            }
                        }
                        catch (cause) {
                            throw new Error(`Failed to process auxiliary resource '${resource.type}:${resource.physicalId}': ${cause}`, { cause });
                        }
                    }
                    // Due to questionable historical design choices, snippets may
                    // reference other snippets in two ways:
                    //
                    // 1. From the same folder (i.e. `require('./other-snippet')`) if
                    //    the requiring snippet is NOT the main entrypoint, but has
                    //    itself been required by another snippet or script.
                    // 2. From the magic './snippets' folder using
                    //    `require('./snippets/other-snippet')` irrespective of whether
                    //    the requiring snippet is the main entrypoint or not (works in
                    //    either case).
                    //
                    // To emulate this functionality with a proper file structure, we
                    // need to check if any global snippets are using the second method,
                    // and create appropriate aliases in the beatifully named
                    // './snippets/snippets/' folder so that the paths can resolve
                    // without modification.
                    for (const globalSnippetFile of globalSnippetFiles) {
                        const content = globalSnippetFile.content.toString();
                        const snippetFiles = context.findScriptSnippetFiles(content);
                        for (const snippetFile of snippetFiles) {
                            const localSnippetFile = program.generatedSupportFile(`snippets/snippets/${snippetFile.basename}`);
                            localSnippetFile.header((0, sourcegen_1.docComment)(`This file has been generated to help resolve cross-snippet imports.\n` +
                                `\n` +
                                `We recommend rewriting your imports to not reference this file, after which\n` +
                                `you may remove it.`));
                            localSnippetFile.plainImport(localSnippetFile.relativePath(snippetFile));
                        }
                    }
                }
                (0, construct_codegen_1.sortResources)(resources);
                for (const resource of resources) {
                    try {
                        codegen.prepare(resource.logicalId, resource, context);
                    }
                    catch (cause) {
                        if (!(cause instanceof Error)) {
                            throw cause;
                        }
                        failures.set(resource.logicalId, {
                            resource,
                            cause,
                        });
                    }
                }
                for (const resource of resources) {
                    if (failures.has(resource.logicalId)) {
                        continue;
                    }
                    try {
                        codegen.gencode(resource.logicalId, resource, context);
                    }
                    catch (cause) {
                        if (!(cause instanceof Error)) {
                            throw cause;
                        }
                        failures.set(resource.logicalId, {
                            resource,
                            cause,
                        });
                    }
                }
            }
            if (failures.size === 0) {
                this.style.actionSuccess();
            }
            else {
                this.style.actionFailure();
            }
            return {
                failures: [...failures.values()],
            };
        }
        catch (err) {
            this.style.actionFailure();
            throw err;
        }
    }
    async #initializeProject(config) {
        const { logicalId, projectName, repoUrl, } = config;
        this.style.actionStart('Checking project status');
        try {
            await api.projects.get(logicalId);
            this.style.actionSuccess();
            // The project has already been initialized, not need to do anything.
            return;
        }
        catch (err) {
            this.style.actionFailure();
            if (!(err instanceof projects_1.ProjectNotFoundError)) {
                throw err;
            }
            // The project does not exist yet and we must create (initialize) it.
        }
        const choices = [{
                title: `Yes, I want to start a new project with the imported resources`,
                value: 'init',
            }, {
                title: `No, I intended to import resources into an existing project`,
                value: 'mistake',
                description: 'Exit and verify your configuration.',
            }, {
                title: 'No, I want to cancel and exit',
                value: 'exit',
                description: 'No changes will be made.',
            }];
        const { action } = await (0, prompts_1.default)({
            name: 'action',
            type: 'select',
            message: 'Your project has not been initialized yet. Initialize now?',
            choices,
        });
        this.log();
        switch (action) {
            case 'init': {
                try {
                    this.style.actionStart('Initializing project');
                    await api.projects.create({
                        name: projectName,
                        logicalId,
                        repoUrl,
                    });
                    this.style.actionSuccess();
                }
                catch (err) {
                    this.style.actionFailure();
                    throw err;
                }
                break;
            }
            case 'mistake':
                this.style.fatal(`Please verify your configuration and try again.`);
                this.cancelAndExit();
                break;
            case 'exit':
            // falls through
            default: {
                this.cancelAndExit();
            }
        }
    }
    async #handleExistingPlans(plans) {
        const choices = [{
                title: 'I want to exit and rethink',
                value: 'exit',
                description: 'No changes will be made.',
            }, {
                title: 'I want to see some basic details about the existing plans first',
                value: 'show',
            }, {
                title: 'I want to cancel all existing plans and create a new plan',
                value: 'cancel-proceed',
            }, {
                title: 'I want to create a new plan regardless',
                value: 'new',
            }];
        while (true) {
            const { action } = await (0, prompts_1.default)({
                name: 'action',
                type: 'select',
                message: `Found ${plans.length} existing uncommitted plan(s). How do you want to proceed?`,
                choices,
            });
            this.log();
            switch (action) {
                case 'show': {
                    this.log();
                    for (const plan of plans) {
                        this.log(`Plan ${plan.id}:`);
                        this.log(`  Created at: ${new Date(plan.createdAt)}`);
                        this.log(`  Applied?:   ${plan.appliedAt ? 'yes' : 'no'}`);
                        if (plan.appliedAt) {
                            this.log(`  Applied at: ${new Date(plan.appliedAt)}`);
                        }
                        this.log();
                    }
                    const { action } = await (0, prompts_1.default)({
                        name: 'action',
                        type: 'select',
                        message: 'Do you want to exit or retry?',
                        choices: [{
                                title: 'Exit',
                                value: 'exit',
                                description: 'No changes will be made.',
                            }, {
                                title: 'Return to previous options',
                                value: 'return',
                            }],
                    });
                    this.log();
                    if (action === 'exit') {
                        this.cancelAndExit();
                    }
                    continue;
                }
                case 'cancel-proceed': {
                    this.style.actionStart('Cancelling existing plans');
                    try {
                        for (const plan of plans) {
                            await api.projects.cancelImportPlan(plan.id);
                            this.style.shortSuccess(`Cancelled plan ${plan.id}`);
                        }
                        this.style.actionSuccess();
                    }
                    catch (err) {
                        this.style.actionFailure();
                        throw err;
                    }
                    return;
                }
                case 'new': {
                    return;
                }
                case 'exit':
                // falls through
                default: {
                    this.cancelAndExit();
                }
            }
        }
    }
    cancelAndExit() {
        this.log('Exiting without making any changes.');
        this.exit(0);
    }
}
exports.default = ImportPlanCommand;
function previewComment() {
    return (0, sourcegen_1.docComment)('This Checkly construct file has been generated for preview purposes only.' +
        '\n\n' +
        'Deploying this file will create duplicate resources.');
}
class InvalidResourceIdentifierError extends Error {
}
function parseFilter(spec) {
    const filter = {
        type: 'include'
    };
    if (spec.startsWith('!')) {
        filter.type = 'exclude';
        spec = spec.slice(1);
    }
    const [type, physicalId] = spec.split(':', 2);
    const parseId = importables[type];
    if (parseId === undefined) {
        throw new Error(`Invalid resource specifier '${spec}': Unsupported resource type '${type}'`);
    }
    try {
        filter.resource = {
            type,
            physicalId: parseId(physicalId),
        };
    }
    catch (err) {
        if (err instanceof InvalidResourceIdentifierError) {
            throw new Error(`Invalid resource specifier '${spec}': ${err.message}`);
        }
        throw err;
    }
    return filter;
}
function integerPhysicalId(value) {
    if (value === undefined) {
        return;
    }
    if (value === '' || value === '*') {
        return;
    }
    const numberValue = parseInt(value, 10);
    if (Number.isNaN(numberValue)) {
        throw new InvalidResourceIdentifierError(`Resource identifier '${value}' must be a valid integer`);
    }
    return numberValue;
}
function uuidPhysicalId(value) {
    if (value === undefined) {
        return;
    }
    if (value === '' || value === '*') {
        return;
    }
    if (!(0, uuid_1.validate)(value)) {
        throw new InvalidResourceIdentifierError(`Resource identifier '${value}' must be a valid UUID`);
    }
    return value;
}
const importables = {
    'alert-channel': integerPhysicalId,
    'check-group': integerPhysicalId,
    'check': uuidPhysicalId,
    'dashboard': integerPhysicalId,
    'maintenance-window': integerPhysicalId,
    'private-location': uuidPhysicalId,
    'status-page-service': uuidPhysicalId,
    'status-page': uuidPhysicalId,
};
function isFilterable(type) {
    return importables[type] !== undefined;
}
//# sourceMappingURL=plan.js.map