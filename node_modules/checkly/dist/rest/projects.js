"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProjectNotFoundError = void 0;
const axios_1 = require("axios");
const util_1 = require("./util");
class ProjectNotFoundError extends Error {
}
exports.ProjectNotFoundError = ProjectNotFoundError;
class Projects {
    api;
    constructor(api) {
        this.api = api;
    }
    getAll() {
        return this.api.get('/next/projects');
    }
    async get(id) {
        try {
            return await this.api.get(`/next/projects/${id}`);
        }
        catch (err) {
            if ((0, axios_1.isAxiosError)(err)) {
                if (err.response?.status === 404) {
                    throw new ProjectNotFoundError();
                }
            }
            throw err;
        }
    }
    create(project) {
        return this.api.post('/next/projects', project);
    }
    async deleteProject(logicalId) {
        try {
            return await this.api.delete(`/next/projects/${logicalId}`);
        }
        catch (err) {
            if ((0, axios_1.isAxiosError)(err)) {
                if (err.response?.status === 404) {
                    throw new ProjectNotFoundError();
                }
            }
            throw err;
        }
    }
    deploy(resources, { dryRun = false, scheduleOnDeploy = true } = {}) {
        return this.api.post(`/next-v2/projects/deploy?dryRun=${dryRun}&scheduleOnDeploy=${scheduleOnDeploy}`, resources, { transformRequest: util_1.compressJSONPayload });
    }
    async createImportPlan(logicalId, options) {
        const payload = {
            filters: options?.filters,
            friends: options?.friends,
        };
        return this.api.post(`/next/projects/${logicalId}/imports`, payload, {
            params: {
                preview: options?.preview ?? false,
            },
        });
    }
    async findImportPlans(logicalId, { onlyUnapplied = false, onlyUncommitted = false } = {}) {
        try {
            return await this.api.get(`/next/projects/${logicalId}/imports`, {
                params: {
                    onlyUnapplied,
                    onlyUncommitted,
                },
            });
        }
        catch (err) {
            if ((0, axios_1.isAxiosError)(err)) {
                if (err.response?.status === 404) {
                    throw new ProjectNotFoundError();
                }
            }
            throw err;
        }
    }
    listImportPlans({ onlyUnapplied = false, onlyUncommitted = false } = {}) {
        return this.api.get('/next/projects/imports', {
            params: {
                onlyUnapplied,
                onlyUncommitted,
            },
        });
    }
    cancelImportPlan(importPlanId) {
        return this.api.delete(`/next/projects/imports/${importPlanId}`);
    }
    applyImportPlan(importPlanId) {
        return this.api.post(`/next/projects/imports/${importPlanId}/apply`);
    }
    commitImportPlan(importPlanId) {
        return this.api.post(`/next/projects/imports/${importPlanId}/commit`);
    }
}
exports.default = Projects;
//# sourceMappingURL=projects.js.map