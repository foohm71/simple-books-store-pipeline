"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.printDeprecationWarning = exports.getTraceUrl = exports.getTestSessionUrl = exports.printLn = exports.print = exports.resultToCheckStatus = exports.formatCheckResult = exports.formatCheckTitle = exports.formatDuration = exports.CheckStatus = void 0;
const chalk_1 = __importDefault(require("chalk"));
const indent_string_1 = __importDefault(require("indent-string"));
const luxon_1 = require("luxon");
const logSymbols = __importStar(require("log-symbols"));
const api_1 = require("../rest/api");
// eslint-disable-next-line no-restricted-syntax
var CheckStatus;
(function (CheckStatus) {
    CheckStatus[CheckStatus["SCHEDULING"] = 0] = "SCHEDULING";
    CheckStatus[CheckStatus["RUNNING"] = 1] = "RUNNING";
    CheckStatus[CheckStatus["RETRIED"] = 2] = "RETRIED";
    CheckStatus[CheckStatus["FAILED"] = 3] = "FAILED";
    CheckStatus[CheckStatus["SUCCESSFUL"] = 4] = "SUCCESSFUL";
    CheckStatus[CheckStatus["DEGRADED"] = 5] = "DEGRADED";
})(CheckStatus || (exports.CheckStatus = CheckStatus = {}));
function formatDuration(ms) {
    if (ms < 1000) {
        return `${ms}ms`;
    }
    else {
        return `${Math.ceil(ms / 1000)}s`;
    }
}
exports.formatDuration = formatDuration;
function formatCheckTitle(status, check, opts = {}) {
    let duration;
    if ((opts.printRetryDuration || status !== CheckStatus.RETRIED) && check.startedAt && check.stoppedAt) {
        const durationMs = luxon_1.DateTime.fromISO(check.stoppedAt)
            .diff(luxon_1.DateTime.fromISO(check.startedAt))
            .toMillis();
        duration = formatDuration(durationMs);
    }
    let statusString;
    let format;
    if (status === CheckStatus.SUCCESSFUL) {
        statusString = chalk_1.default.bold.green(logSymbols.success);
        format = chalk_1.default.bold;
    }
    else if (status === CheckStatus.FAILED) {
        statusString = logSymbols.error;
        format = chalk_1.default.bold.red;
    }
    else if (status === CheckStatus.DEGRADED) {
        statusString = logSymbols.warning;
        format = chalk_1.default.bold.yellow;
    }
    else if (status === CheckStatus.SCHEDULING) {
        statusString = '~';
        format = chalk_1.default.bold.dim;
    }
    else if (status === CheckStatus.RETRIED) {
        statusString = '↺';
        format = chalk_1.default.bold;
    }
    else {
        statusString = '-';
        format = chalk_1.default.bold.dim;
    }
    return [
        format(statusString),
        opts.includeSourceFile ? format(`${check.sourceFile} >`) : undefined,
        format(check.name),
        duration ? `(${duration})` : undefined,
    ].filter(Boolean).join(' ');
}
exports.formatCheckTitle = formatCheckTitle;
function formatCheckResult(checkResult) {
    const result = [];
    if (checkResult.checkType === 'API') {
        // Order should follow the check lifecycle (response, then assertions)
        if (checkResult.checkRunData?.requestError) {
            result.push([
                formatSectionTitle('Request Error'),
                checkResult.checkRunData.requestError,
            ]);
        }
        else {
            if (checkResult.checkRunData?.request) {
                result.push([
                    formatSectionTitle('HTTP Request'),
                    formatHttpRequest(checkResult.checkRunData.request),
                ]);
            }
            if (checkResult.checkRunData?.response) {
                result.push([
                    formatSectionTitle('HTTP Response'),
                    formatHttpResponse(checkResult.checkRunData.response),
                ]);
            }
            if (checkResult.checkRunData?.assertions?.length) {
                result.push([
                    formatSectionTitle('Assertions'),
                    formatAssertions(checkResult.checkRunData.assertions),
                ]);
            }
            if (checkResult.logs?.setup.length) {
                result.push([
                    formatSectionTitle('Setup Script Logs'),
                    formatLogs(checkResult.logs.setup),
                ]);
            }
            if (checkResult.logs?.teardown.length) {
                result.push([
                    formatSectionTitle('Teardown Script Logs'),
                    formatLogs(checkResult.logs.teardown),
                ]);
            }
        }
    }
    if (checkResult.checkType === 'TCP') {
        if (checkResult.checkRunData?.requestError) {
            result.push([
                formatSectionTitle('Request Error'),
                checkResult.checkRunData.requestError,
            ]);
        }
        else {
            if (checkResult.checkRunData?.response?.error) {
                result.push([
                    formatSectionTitle('Connection Error'),
                    formatConnectionError(checkResult.checkRunData?.response?.error),
                ]);
            }
            if (checkResult.checkRunData?.assertions?.length) {
                result.push([
                    formatSectionTitle('Assertions'),
                    formatAssertions(checkResult.checkRunData.assertions),
                ]);
            }
        }
    }
    if (checkResult.logs?.length) {
        result.push([
            formatSectionTitle('Logs'),
            formatLogs(checkResult.logs),
        ]);
    }
    if (checkResult.runError) {
        result.push([
            formatSectionTitle('Execution Error'),
            formatRunError(checkResult.runError),
        ]);
    }
    if (checkResult.scheduleError) {
        result.push([
            formatSectionTitle('Scheduling Error'),
            formatRunError(checkResult.scheduleError),
        ]);
    }
    return result.map(([title, body]) => title + '\n' + body).join('\n\n');
}
exports.formatCheckResult = formatCheckResult;
const assertionSources = {
    STATUS_CODE: 'status code',
    JSON_BODY: 'JSON body',
    HEADERS: 'headers',
    TEXT_BODY: 'text body',
    RESPONSE_TIME: 'response time',
    RESPONSE_DATA: 'response data',
};
const assertionComparisons = {
    EQUALS: 'equals',
    NOT_EQUALS: 'doesn\'t equal',
    HAS_KEY: 'has key',
    NOT_HAS_KEY: 'doesn\'t have key',
    HAS_VALUE: 'has value',
    NOT_HAS_VALUE: 'doesn\'t have value',
    IS_EMPTY: 'is empty',
    NOT_EMPTY: 'is not empty',
    GREATER_THAN: 'is greater than',
    LESS_THAN: 'is less than',
    CONTAINS: 'contains',
    NOT_CONTAINS: 'doesn\'t contain',
    IS_NULL: 'is null',
    NOT_NULL: 'is not null',
};
function formatAssertions(assertions) {
    return assertions.map(({ source, property, comparison, target, regex, error, actual }) => {
        const assertionFailed = !!error;
        const humanSource = assertionSources[source] || source;
        const humanComparison = assertionComparisons[comparison] || comparison;
        let actualString;
        if (actual) {
            const { result: truncatedActual, lines: truncatedActualLines } = truncate(actual, {
                chars: 300,
                lines: 5,
                ending: chalk_1.default.magenta('\n...truncated...'),
            });
            if (truncatedActualLines <= 1) {
                actualString = `Received: ${truncatedActual}.`;
            }
            else {
                actualString = `Received:\n${(0, indent_string_1.default)(truncatedActual, 4, { indent: ' ' })}`;
            }
        }
        const message = [
            assertionFailed ? logSymbols.error : logSymbols.success,
            humanSource,
            property ? `property "${property}"` : undefined,
            regex ? `regex "${regex}"` : undefined,
            humanComparison,
            `target "${target}".`,
            actualString,
        ].filter(Boolean).join(' ');
        return assertionFailed ? chalk_1.default.red(message) : chalk_1.default.green(message);
    }).join('\n');
}
function formatHttpRequest(request) {
    const { result: stringBody } = truncate(request.data, {
        chars: 20 * 100,
        lines: 20,
        ending: chalk_1.default.magenta('\n...truncated...'),
    });
    const headersString = Object.entries(request.headers ?? []).map(([key, val]) => `${key}: ${val}`).join('\n');
    return [
        `${request.method} ${request.url}`,
        'Headers:',
        (0, indent_string_1.default)(headersString, 2),
        request.data ? 'Body:' : undefined,
        (0, indent_string_1.default)(stringBody, 2),
    ].filter(Boolean).join('\n');
}
function formatHttpResponse(response) {
    // TODO: Provide a user for a way to see the full response. For example, write it to a file.
    const { result: stringBody } = truncate(response.body, {
        chars: 20 * 100,
        lines: 20,
        ending: chalk_1.default.magenta('\n...truncated...'),
    });
    const headersString = Object.entries(response.headers ?? []).map(([key, val]) => `${key}: ${val}`).join('\n');
    return [
        `Status Code: ${response.status} ${response.statusText}`,
        'Headers:',
        (0, indent_string_1.default)(headersString, 2),
        response.body ? 'Body:' : undefined,
        (0, indent_string_1.default)(stringBody, 2),
    ].filter(Boolean).join('\n');
}
function isDNSLookupFailureError(error) {
    return error.code === 'ENOTFOUND' &&
        typeof error.syscall === 'string' &&
        typeof error.hostname === 'string';
}
function isConnectionRefusedError(error) {
    return error.code === 'ECONNREFUSED' &&
        typeof error.syscall === 'string' &&
        typeof error.address === 'string' &&
        typeof error.port === 'number' &&
        typeof (error.errno ?? 0) === 'number';
}
function isSocketTimeoutError(error) {
    return error.code === 'SOCKET_TIMEOUT' &&
        typeof error.address === 'string' &&
        typeof error.port === 'number';
}
function isInvalidIPAddressError(error) {
    return error.code === 'ERR_INVALID_IP_ADDRESS';
}
function formatConnectionError(error) {
    if (isDNSLookupFailureError(error)) {
        const message = [
            logSymbols.error,
            `DNS lookup for "${error.hostname}" failed`,
            `(syscall: ${error.syscall})`,
        ].join(' ');
        return chalk_1.default.red(message);
    }
    if (isConnectionRefusedError(error)) {
        const message = [
            logSymbols.error,
            `Connection to "${error.address}:${error.port}" was refused`,
            `(syscall: ${error.syscall}, errno: ${error.errno ?? '<None>'})`,
        ].join(' ');
        return chalk_1.default.red(message);
    }
    if (isSocketTimeoutError(error)) {
        const message = [
            logSymbols.error,
            `Connection to "${error.address}:${error.port}" timed out (perhaps connection was never closed)`,
        ].join(' ');
        return chalk_1.default.red(message);
    }
    if (isInvalidIPAddressError(error)) {
        const message = [
            logSymbols.error,
            'Invalid IP address (perhaps hostname and IP family do not match)',
        ].join(' ');
        return chalk_1.default.red(message);
    }
    // Some other error we don't have detection for.
    if (error.code !== undefined) {
        const { code, ...extra } = error;
        const detailsString = JSON.stringify(extra);
        const message = [
            logSymbols.error,
            `${code} (details: ${detailsString})`,
        ].join(' ');
        return chalk_1.default.red(message);
    }
    // If we don't even have a code, give up and output the whole thing.
    const detailsString = JSON.stringify(error);
    const message = [
        logSymbols.error,
        `Error (details: ${detailsString})`,
    ].join(' ');
    return chalk_1.default.red(message);
}
function formatLogs(logs) {
    return logs.flatMap(({ level, msg, time }) => {
        const timestamp = luxon_1.DateTime.fromMillis(time).toLocaleString(luxon_1.DateTime.TIME_24_WITH_SECONDS);
        let format = chalk_1.default.dim;
        if (level === 'WARN') {
            format = chalk_1.default.dim.yellow;
        }
        else if (level === 'ERROR') {
            format = chalk_1.default.dim.red;
        }
        const [firstLine, ...remainingLines] = msg.split('\n');
        return [
            `${timestamp} ${level.padEnd(5, ' ')} ${format(firstLine)}`,
            ...remainingLines.map((line) => format(line)),
        ];
    }).join('\n');
}
function formatRunError(err) {
    if (typeof err === 'string') {
        return err;
    }
    else {
        return err.message;
    }
}
function formatSectionTitle(title) {
    const width = process.stdout.isTTY ? process.stdout.columns : 80;
    // For style reasons, we only extend the title with "----" to a maximum of 80 characters
    const targetTitleWidth = Math.min(width, 80);
    const leftPaddingLength = 6; // Account for an indent of 4 and two dashes
    // On CI, process.stdout.columns might be 0
    // We take Math.max(0, ...) to avoid a negative padding length from causing errors
    const rightPaddingLength = Math.max(0, targetTitleWidth - title.length - leftPaddingLength);
    return `──${chalk_1.default.bold(title)}${'─'.repeat(rightPaddingLength)}`;
}
function truncate(val, opts) {
    let truncated = false;
    let result = toString(val);
    if (opts.chars && val.length > opts.chars) {
        truncated = true;
        result = result.substring(0, opts.chars);
    }
    const lines = result.split('\n');
    if (opts.lines && lines.length > opts.lines) {
        truncated = true;
        result = lines.slice(0, opts.lines).join('\n');
    }
    return {
        truncated,
        result: truncated && opts.ending ? result + opts.ending : result,
        lines: opts.lines ? Math.min(opts.lines, lines.length) : lines.length,
    };
}
function toString(val) {
    if (typeof val === 'object') {
        return JSON.stringify(val, null, 2);
    }
    else {
        return val.toString();
    }
}
function resultToCheckStatus(checkResult) {
    return checkResult.hasFailures
        ? CheckStatus.FAILED
        : checkResult.isDegraded
            ? CheckStatus.DEGRADED
            : CheckStatus.SUCCESSFUL;
}
exports.resultToCheckStatus = resultToCheckStatus;
function print(text) {
    process.stdout.write(text);
}
exports.print = print;
function printLn(text, afterLnCount = 1, beforeLnCount = 0) {
    process.stdout.write(`${'\n'.repeat(beforeLnCount)}${text}${'\n'.repeat(afterLnCount)}`);
}
exports.printLn = printLn;
function getTestSessionUrl(testSessionId) {
    const { baseURL } = (0, api_1.getDefaults)();
    return `${baseURL.replace(/api/, 'app')}/test-sessions/${testSessionId}`;
}
exports.getTestSessionUrl = getTestSessionUrl;
function getTraceUrl(traceUrl) {
    return `https://trace.playwright.dev/?trace=${encodeURIComponent(traceUrl)}`;
}
exports.getTraceUrl = getTraceUrl;
function printDeprecationWarning(text) {
    process.stdout.write(chalk_1.default.yellow(`\n${logSymbols.warning} Deprecation warning: ${text} \n`));
}
exports.printDeprecationWarning = printDeprecationWarning;
//# sourceMappingURL=util.js.map