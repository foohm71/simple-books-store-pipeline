"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StaticAuxiliaryFile = exports.GeneratedFile = exports.ProgramFile = exports.Program = void 0;
const promises_1 = require("node:fs/promises");
const node_path_1 = __importStar(require("node:path"));
const output_1 = require("./output");
class Program {
    #options;
    #ext;
    #generatedFiles = new Map();
    #staticAuxiliaryFiles = new Map();
    constructor(options) {
        this.#options = {
            ...options,
        };
        switch (options.language) {
            case 'typescript':
                this.#ext = '.ts';
                break;
            case 'javascript':
                this.#ext = '.js';
                break;
            default:
                throw new Error(`Unknown value '${options.language}' for \`ProgramOptions.language\``);
        }
    }
    get paths() {
        const paths = [];
        for (const file of this.#generatedFiles.values()) {
            paths.push(node_path_1.default.join(this.#options.rootDirectory, file.path));
        }
        for (const file of this.#staticAuxiliaryFiles.values()) {
            paths.push(node_path_1.default.join(this.#options.rootDirectory, file.path));
        }
        paths.sort();
        return paths;
    }
    generatedConstructFile(path) {
        if (this.#shouldModifyPath(path)) {
            path += this.#options.constructFileSuffix;
            path += this.#ext;
        }
        let file = this.#generatedFiles.get(path);
        if (file === undefined) {
            file = new GeneratedFile(path);
            for (const header of this.#options.constructHeaders ?? []) {
                file.header(header);
            }
            this.#generatedFiles.set(path, file);
        }
        return file;
    }
    generatedSupportFile(path) {
        if (this.#shouldModifyPath(path)) {
            path += this.#ext;
        }
        let file = this.#generatedFiles.get(path);
        if (file === undefined) {
            file = new GeneratedFile(path);
            this.#generatedFiles.set(path, file);
        }
        return file;
    }
    staticSpecFile(path, content) {
        if (this.#shouldModifyPath(path)) {
            path += this.#options.specFileSuffix;
            path += this.#ext;
        }
        const file = new StaticAuxiliaryFile(path, content);
        this.#staticAuxiliaryFiles.set(path, file);
        return file;
    }
    staticStyleFile(path, content) {
        if (this.#shouldModifyPath(path)) {
            path += '.css';
        }
        const file = new StaticAuxiliaryFile(path, content);
        this.#staticAuxiliaryFiles.set(path, file);
        return file;
    }
    staticSupportFile(path, content) {
        if (this.#shouldModifyPath(path)) {
            path += this.#ext;
        }
        const file = new StaticAuxiliaryFile(path, content);
        this.#staticAuxiliaryFiles.set(path, file);
        return file;
    }
    #shouldModifyPath(path) {
        // Don't add extensions if it looks like we already have some.
        return (0, node_path_1.extname)(path) === '';
    }
    async realize() {
        for (const file of this.#generatedFiles.values()) {
            const fullFilePath = node_path_1.default.resolve(this.#options.rootDirectory, file.path);
            const { dir: fileDir } = node_path_1.default.parse(fullFilePath);
            if (fileDir !== '') {
                await (0, promises_1.mkdir)(fileDir, {
                    recursive: true,
                });
            }
            const output = new output_1.Output();
            try {
                file.render(output);
            }
            catch (cause) {
                throw new Error(`Failed to render output file '${fullFilePath}': ${cause}`, { cause });
            }
            await (0, promises_1.writeFile)(fullFilePath, output.finalize());
        }
        for (const file of this.#staticAuxiliaryFiles.values()) {
            const fullFilePath = node_path_1.default.resolve(this.#options.rootDirectory, file.path);
            const { dir: fileDir } = node_path_1.default.parse(fullFilePath);
            if (fileDir !== '') {
                await (0, promises_1.mkdir)(fileDir, {
                    recursive: true,
                });
            }
            await (0, promises_1.writeFile)(fullFilePath, file.content);
        }
    }
}
exports.Program = Program;
class ProgramFile {
    path;
    constructor(path) {
        this.path = path;
    }
    get dirname() {
        return node_path_1.default.dirname(this.path);
    }
    get basename() {
        return node_path_1.default.basename(this.path);
    }
    relativePath(to) {
        let relpath = node_path_1.default.relative(this.dirname, to.path);
        if (!relpath.startsWith('.')) {
            relpath = `./${relpath}`;
        }
        return posixPath(relpath);
    }
}
exports.ProgramFile = ProgramFile;
function posixPath(path) {
    return path.replace(/\\/g, '/');
}
function sortNamedImports(imports) {
    return Array.from(imports).sort((a, b) => {
        const valueA = [a.identifier, a.alias].join(', ');
        const valueB = [b.identifier, b.alias].join(', ');
        return valueA.localeCompare(valueB);
    });
}
class GeneratedFile extends ProgramFile {
    #namedImports = new Map();
    #plainImports = new Set();
    #sections = [];
    #headers = [];
    namedImport(identifier, from, options) {
        from = this.#processImportFrom(from, options);
        const namedImports = this.#namedImports.get(from) ?? [];
        for (const namedImport of namedImports) {
            if (namedImport.identifier === identifier && namedImport.alias === options?.alias) {
                // Already imported.
                return;
            }
        }
        namedImports.push({
            identifier,
            alias: options?.alias,
        });
        this.#namedImports.set(from, namedImports);
    }
    plainImport(from, options) {
        from = this.#processImportFrom(from, options);
        this.#plainImports.add(from);
    }
    #processImportFrom(from, options) {
        let relativeTo = options?.relativeTo;
        if (relativeTo === undefined && options?.relativeToSelf) {
            relativeTo = node_path_1.default.dirname(this.path);
        }
        if (relativeTo !== undefined) {
            from = node_path_1.default.relative(relativeTo, from);
            if (!from.startsWith('.')) {
                from = `./${from}`;
            }
            from = posixPath(from);
        }
        // Shouldn't have imports with .ts extensions.
        if (from.endsWith('.ts') || from.endsWith('.js')) {
            from = from.slice(0, -3);
        }
        return from;
    }
    header(header) {
        this.#headers.push(header);
    }
    section(content) {
        this.#sections.push(content);
    }
    render(output) {
        for (const header of this.#headers) {
            header.render(output);
            output.endLine();
            output.endLine();
        }
        if (this.#namedImports.size > 0) {
            for (const [pkg, imports] of this.#namedImports.entries()) {
                output.append('import');
                output.cosmeticWhitespace();
                output.append('{');
                let first = true;
                for (const { identifier, alias } of sortNamedImports(imports)) {
                    if (!first) {
                        output.append(',');
                    }
                    output.cosmeticWhitespace();
                    first = false;
                    output.append(identifier);
                    if (alias !== undefined) {
                        output.significantWhitespace();
                        output.append('as');
                        output.significantWhitespace();
                        output.append(alias);
                    }
                }
                output.cosmeticWhitespace();
                output.append('}');
                output.significantWhitespace();
                output.append('from');
                output.significantWhitespace();
                output.append(`'${pkg}'`);
                output.endLine();
            }
        }
        if (this.#plainImports.size > 0) {
            for (const pkg of this.#plainImports.values()) {
                output.append('import');
                output.significantWhitespace();
                output.append(`'${pkg}'`);
                output.endLine();
            }
        }
        for (const section of this.#sections) {
            output.endLine();
            section.render(output);
            output.endLine();
        }
    }
}
exports.GeneratedFile = GeneratedFile;
class StaticAuxiliaryFile extends ProgramFile {
    content;
    constructor(path, content) {
        super(path);
        this.content = content;
    }
}
exports.StaticAuxiliaryFile = StaticAuxiliaryFile;
//# sourceMappingURL=program.js.map