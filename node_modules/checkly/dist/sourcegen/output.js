"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Output = void 0;
class OutputBuffer {
    #chunks = [];
    append(data) {
        this.#chunks.push(data);
    }
    finalize() {
        return this.#chunks.join('');
    }
}
class OutputLine {
    #level;
    #chunks = [];
    constructor(level) {
        this.#level = level;
    }
    get level() {
        return this.#level;
    }
    isEmpty() {
        return this.#chunks.length === 0;
    }
    append(value) {
        this.#chunks.push(value);
    }
    collect(buf) {
        buf.append('  '.repeat(this.#level));
        buf.append(this.#chunks.join(''));
        buf.append('\n');
    }
}
class Output {
    #level = 0;
    #lines = [];
    #currentLine;
    constructor(level = 0) {
        this.#level = level;
        this.#currentLine = new OutputLine(this.#level);
        this.#lines.push(this.#currentLine);
    }
    increaseIndent() {
        this.#level += 1;
    }
    decreaseIndent() {
        this.#level -= 1;
    }
    endLine(options) {
        if (options?.collapse && this.#currentLine.isEmpty()) {
            return;
        }
        this.#currentLine = new OutputLine(this.#level);
        this.#lines.push(this.#currentLine);
    }
    append(value) {
        this.#currentLine.append(value);
    }
    significantWhitespace() {
        this.append(' ');
    }
    cosmeticWhitespace() {
        this.append(' ');
    }
    finalize() {
        // Remove trailing empty lines.
        for (;;) {
            const line = this.#lines.pop();
            if (line === undefined) {
                break;
            }
            if (!line.isEmpty()) {
                this.#lines.push(line);
                break;
            }
        }
        const buf = new OutputBuffer();
        for (const line of this.#lines) {
            line.collect(buf);
        }
        return buf.finalize();
    }
}
exports.Output = Output;
//# sourceMappingURL=output.js.map