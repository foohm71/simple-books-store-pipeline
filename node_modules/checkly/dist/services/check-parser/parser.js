"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Parser = void 0;
const path = __importStar(require("path"));
const fs = __importStar(require("fs"));
const fsAsync = __importStar(require("fs/promises"));
const acorn = __importStar(require("acorn"));
const walk = __importStar(require("acorn-walk"));
const collector_1 = require("./collector");
const errors_1 = require("./errors");
const resolver_1 = require("./package-files/resolver");
const util_1 = require("../util");
// Our custom configuration to handle walking errors
const ignore = (_node, _st, _c) => { };
const PACKAGE_EXTENSION = `${path.sep}package.json`;
const supportedBuiltinModules = [
    'node:assert',
    'node:buffer',
    'node:crypto',
    'node:dns',
    'node:fs',
    'node:path',
    'node:querystring',
    'node:readline',
    'node:stream',
    'node:string_decoder',
    'node:timers',
    'node:tls',
    'node:url',
    'node:util',
    'node:zlib',
];
function validateEntrypoint(entrypoint) {
    const extension = path.extname(entrypoint);
    if (extension !== '.js' && extension !== '.ts' && extension !== '.mjs') {
        throw new Error(`Unsupported file extension for ${entrypoint}`);
    }
    try {
        const content = fs.readFileSync(entrypoint, { encoding: 'utf-8' });
        return { extension, content };
    }
    catch (err) {
        throw new errors_1.DependencyParseError(entrypoint, [entrypoint], [], []);
    }
}
let tsParser;
function getTsParser() {
    if (tsParser) {
        return tsParser;
    }
    try {
        // eslint-disable-next-line @typescript-eslint/no-require-imports
        tsParser = require('@typescript-eslint/typescript-estree');
        const AST_NODE_TYPES = tsParser.AST_NODE_TYPES;
        // Our custom configuration to handle walking errors
        Object.values(AST_NODE_TYPES).forEach((astType) => {
            // Only handle the TS specific ones
            if (!astType.startsWith('TS')) {
                return;
            }
            const base = walk.base;
            base[astType] = base[astType] ?? ignore;
        });
        return tsParser;
    }
    catch (err) {
        if (err.code === 'ERR_MODULE_NOT_FOUND' || err.code === 'MODULE_NOT_FOUND') {
            throw new Error('Please install "typescript" to use TypeScript-code in check files');
        }
        throw err;
    }
}
class Parser {
    supportedModules;
    checkUnsupportedModules;
    resolver = new resolver_1.PackageFilesResolver();
    cache = new Map();
    // TODO: pass a npm matrix of supported npm modules
    // Maybe pass a cache so we don't have to fetch files separately all the time
    constructor(options) {
        this.supportedModules = new Set(supportedBuiltinModules.concat(options.supportedNpmModules ?? []));
        this.checkUnsupportedModules = options.checkUnsupportedModules ?? true;
    }
    supportsModule(importPath) {
        if (this.supportedModules.has(importPath)) {
            return true;
        }
        if (this.supportedModules.has('node:' + importPath)) {
            return true;
        }
        return false;
    }
    async validateFileAsync(filePath) {
        const extension = path.extname(filePath);
        if (extension !== '.js' && extension !== '.ts' && extension !== '.mjs') {
            throw new Error(`Unsupported file extension for ${filePath}`);
        }
        try {
            const content = await fsAsync.readFile(filePath, { encoding: 'utf-8' });
            return { filePath, content };
        }
        catch (err) {
            throw new errors_1.DependencyParseError(filePath, [filePath], [], []);
        }
    }
    async getFilesAndDependencies(paths) {
        const files = new Set(await this.getFilesFromPaths(paths));
        const errors = new Set();
        const missingFiles = new Set();
        const resultFileSet = new Set();
        for (const file of files) {
            if (resultFileSet.has(file)) {
                continue;
            }
            if (file.endsWith('.json')) {
                // Holds info about the main file and doesn't need to be parsed
                resultFileSet.add(file);
                continue;
            }
            const item = await this.validateFileAsync(file);
            const cache = this.cache.get(item.filePath);
            const { module, error } = cache !== undefined
                ? cache
                : Parser.parseDependencies(item.filePath, item.content);
            if (error) {
                this.cache.set(item.filePath, { module, error });
                errors.add(item.filePath);
                continue;
            }
            const resolvedDependencies = cache?.resolvedDependencies ??
                this.resolver.resolveDependenciesForFilePath(item.filePath, module.dependencies);
            for (const dep of resolvedDependencies.missing) {
                missingFiles.add((0, util_1.pathToPosix)(dep.filePath));
            }
            this.cache.set(item.filePath, { module, resolvedDependencies });
            for (const dep of resolvedDependencies.local) {
                if (resultFileSet.has(dep.sourceFile.meta.filePath)) {
                    continue;
                }
                const filePath = dep.sourceFile.meta.filePath;
                files.add(filePath);
            }
            resultFileSet.add((0, util_1.pathToPosix)(item.filePath));
        }
        if (missingFiles.size) {
            throw new errors_1.DependencyParseError(paths.join(', '), Array.from(missingFiles), [], []);
        }
        return { files: Array.from(resultFileSet), errors: Array.from(errors) };
    }
    async getFilesFromPaths(paths) {
        const files = paths.map(async (currPath) => {
            const normalizedPath = (0, util_1.pathToPosix)(currPath);
            try {
                const stats = await fsAsync.lstat(normalizedPath);
                if (stats.isDirectory()) {
                    return (0, util_1.findFilesWithPattern)(normalizedPath, '**/*.{js,ts,mjs}', []);
                }
                return [normalizedPath];
            }
            catch (err) {
                if (normalizedPath.includes('*') || normalizedPath.includes('?') || normalizedPath.includes('{')) {
                    return (0, util_1.findFilesWithPattern)(process.cwd(), normalizedPath, []);
                }
                else {
                    return [];
                }
            }
        });
        const filesArray = await Promise.all(files);
        return filesArray.flat();
    }
    parse(entrypoint) {
        const { content } = validateEntrypoint(entrypoint);
        /*
      * The importing of files forms a directed graph.
      * Vertices are source files and edges are from importing other files.
      * We can find all of the files we need to run the check by traversing this graph.
      * In this implementation, we use breadth first search.
      */
        const collector = new collector_1.Collector(entrypoint, content);
        const bfsQueue = [{ filePath: entrypoint, content }];
        while (bfsQueue.length > 0) {
            // Since we just checked the length, shift() will never return undefined.
            // We can add a not-null assertion operator (!).
            const item = bfsQueue.shift();
            if (item.filePath.endsWith(PACKAGE_EXTENSION)) {
                // Holds info about the main file and doesn't need to be parsed
                continue;
            }
            // This cache is only useful when there are multiple entrypoints with
            // common files, as we make sure to not add the same file twice to
            // bfsQueue.
            const cache = this.cache.get(item.filePath);
            const { module, error } = cache !== undefined
                ? cache
                : Parser.parseDependencies(item.filePath, item.content);
            if (error) {
                this.cache.set(item.filePath, { module, error });
                collector.addParsingError(item.filePath, error.message);
                continue;
            }
            const resolvedDependencies = cache?.resolvedDependencies ??
                this.resolver.resolveDependenciesForFilePath(item.filePath, module.dependencies);
            this.cache.set(item.filePath, { module, resolvedDependencies });
            if (this.checkUnsupportedModules) {
                const unsupportedDependencies = resolvedDependencies.external.flatMap(dep => {
                    if (!this.supportsModule(dep.importPath)) {
                        return [dep.importPath];
                    }
                    else {
                        return [];
                    }
                });
                if (unsupportedDependencies.length) {
                    collector.addUnsupportedNpmDependencies(item.filePath, unsupportedDependencies);
                }
            }
            for (const dep of resolvedDependencies.missing) {
                collector.addMissingFile(dep.filePath);
            }
            for (const dep of resolvedDependencies.local) {
                const filePath = dep.sourceFile.meta.filePath;
                if (collector.hasDependency(filePath)) {
                    continue;
                }
                collector.addDependency(filePath, dep.sourceFile.contents);
                bfsQueue.push({ filePath, content: dep.sourceFile.contents });
            }
        }
        collector.validate();
        return collector.getItems();
    }
    static parseDependencies(filePath, contents) {
        const dependencies = new Set();
        const extension = path.extname(filePath);
        try {
            if (extension === '.js' || extension === '.mjs') {
                const ast = acorn.parse(contents, {
                    allowReturnOutsideFunction: true,
                    ecmaVersion: 'latest',
                    allowImportExportEverywhere: true,
                    allowAwaitOutsideFunction: true,
                });
                walk.simple(ast, Parser.jsNodeVisitor(dependencies));
            }
            else if (extension === '.ts') {
                const tsParser = getTsParser();
                const ast = tsParser.parse(contents, {});
                // The AST from typescript-estree is slightly different from the type used by acorn-walk.
                // This doesn't actually cause problems (both are "ESTree's"), but we need to ignore type errors here.
                // @ts-ignore
                walk.simple(ast, Parser.tsNodeVisitor(tsParser, dependencies));
            }
            else if (extension === '.json') {
                // No dependencies to check.
            }
            else {
                throw new Error(`Unsupported file extension for ${filePath}`);
            }
        }
        catch (err) {
            return {
                module: {
                    dependencies: Array.from(dependencies),
                },
                error: err,
            };
        }
        return {
            module: {
                dependencies: Array.from(dependencies),
            },
        };
    }
    static jsNodeVisitor(dependencies) {
        return {
            CallExpression(node) {
                if (!Parser.isRequireExpression(node))
                    return;
                const requireStringArg = Parser.getRequireStringArg(node);
                Parser.registerDependency(requireStringArg, dependencies);
            },
            ImportDeclaration(node) {
                if (node.source.type !== 'Literal')
                    return;
                Parser.registerDependency(node.source.value, dependencies);
            },
            ExportNamedDeclaration(node) {
                if (node.source === null)
                    return;
                if (node.source.type !== 'Literal')
                    return;
                Parser.registerDependency(node.source.value, dependencies);
            },
            ExportAllDeclaration(node) {
                if (node.source === null)
                    return;
                if (node.source.type !== 'Literal')
                    return;
                Parser.registerDependency(node.source.value, dependencies);
            },
        };
    }
    static tsNodeVisitor(tsParser, dependencies) {
        return {
            // While rare, TypeScript files may also use require.
            CallExpression(node) {
                if (!Parser.isRequireExpression(node))
                    return;
                const requireStringArg = Parser.getRequireStringArg(node);
                Parser.registerDependency(requireStringArg, dependencies);
            },
            ImportDeclaration(node) {
                // For now, we only support literal strings in the import statement
                if (node.source.type !== tsParser.TSESTree.AST_NODE_TYPES.Literal)
                    return;
                Parser.registerDependency(node.source.value, dependencies);
            },
            ExportNamedDeclaration(node) {
                // The statement isn't importing another dependency
                if (node.source === null)
                    return;
                // For now, we only support literal strings in the export statement
                if (node.source.type !== tsParser.TSESTree.AST_NODE_TYPES.Literal)
                    return;
                Parser.registerDependency(node.source.value, dependencies);
            },
            ExportAllDeclaration(node) {
                if (node.source === null)
                    return;
                // For now, we only support literal strings in the export statement
                if (node.source.type !== tsParser.TSESTree.AST_NODE_TYPES.Literal)
                    return;
                Parser.registerDependency(node.source.value, dependencies);
            },
        };
    }
    static isRequireExpression(node) {
        if (node.type !== 'CallExpression') {
            // Ignore AST nodes that aren't call expressions
            return false;
        }
        else if (node.arguments.length === 0) {
            // Weird case of `require()` or `module.require()` without arguments
            return false;
        }
        else if (node.callee.type === 'Identifier') {
            // Handle the case of a simple call to `require('dependency')`
            return node.callee.name === 'require';
        }
        else if (node.callee.type === 'MemberExpression') {
            // Handle calls to `module.require('dependency')`
            const { object, property } = node.callee;
            return object.type === 'Identifier' &&
                object.name === 'module' &&
                property.type === 'Identifier' &&
                property.name === 'require';
        }
        else {
            return false;
        }
    }
    static getRequireStringArg(node) {
        if (node.arguments[0].type === 'Literal') {
            return node.arguments[0].value;
        }
        else if (node.arguments[0].type === 'TemplateLiteral') {
            return node.arguments[0].quasis[0].value.cooked;
        }
        else {
            /*
            * It might be that `require` is called with a variable - `require(myPackage)`.
            * Unfortunately supporting that case would be complicated.
            * We just skip the dependency and hope that the check still works.
            */
            return null;
        }
    }
    static registerDependency(importArg, dependencies) {
        // TODO: We currently don't support import path aliases, f.ex: `import { Something } from '@services/my-service'`
        if (!importArg) {
            // If there's no importArg, don't register a dependency
        }
        else {
            dependencies.add(importArg);
        }
    }
}
exports.Parser = Parser;
//# sourceMappingURL=parser.js.map