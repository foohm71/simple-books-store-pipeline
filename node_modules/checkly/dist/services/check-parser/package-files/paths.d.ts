type Paths = Record<string, Array<string>>;
declare class TargetPathSpec {
    /**
     * Prefix is the part of the path before an asterisk (wildcard), or the
     * whole path if there's no asterisk.
     *
     * Examples of possible values:
     *   - `"./foo/*"` (from `"./foo/"`)
     *   - `"./bar/foo-"` (from `"./bar/foo-*.js"`)
     *   - `"./bar."` (from `"./bar.*.ts"`)
     *   - `""` (from `"*"`)
     */
    prefix: string;
    /**
     * Suffix is the part of the path after the asterisk (wildcard), if any.
     */
    suffix?: string;
    protected constructor(prefix: string, suffix?: string);
    toPath(joker?: string): string;
    static create(spec: string): TargetPathSpec;
}
export type TargetPathResult = {
    spec: TargetPathSpec;
    path: string;
};
declare class PathMatchResult {
    ok: boolean;
    results: TargetPathResult[];
    private constructor();
    static some(results: TargetPathResult[]): PathMatchResult;
    static none(): PathMatchResult;
}
interface PathMatcher {
    get prefixLength(): number;
    match(importPath: string): PathMatchResult;
}
declare class SourcePathSpec {
    /**
     * Prefix is the part of the path before an asterisk (wildcard), or the
     * whole path if there's no asterisk.
     *
     * Examples of possible values:
     *   - `"@/"` (from `"@/*"`)
     *   - `"app/foo-"` (from `"app/foo-*.js"`)
     *   - `"bar."` (from `"bar.*.ts"`)
     *   - `""` (from `"*"`)
     */
    prefix: string;
    /**
     * Suffix is the part of the path after the asterisk (wildcard), if any.
     */
    suffix?: string;
    protected constructor(prefix: string, suffix?: string);
    matcherForTarget(target: TargetPathSpec[]): PathMatcher;
    static create(spec: string): SourcePathSpec;
}
type SourcePathSpecMatcher = {
    spec: SourcePathSpec;
    matcher: PathMatcher;
};
export type SourcePathResult = {
    spec: SourcePathSpec;
    path: string;
};
export type PathResult = {
    source: SourcePathResult;
    target: TargetPathResult;
};
export type ResolveResult = PathResult[];
export declare class PathResolver {
    baseUrl: string;
    matchers: SourcePathSpecMatcher[];
    private constructor();
    resolve(importPath: string): ResolveResult;
    static createFromPaths(baseUrl: string, paths: Paths): PathResolver;
    private static matcherForPath;
}
export declare function isLocalPath(importPath: string): boolean;
export declare function isBuiltinPath(importPath: string): boolean;
export {};
