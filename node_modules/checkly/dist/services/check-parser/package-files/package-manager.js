"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.detectPackageManager = exports.knownPackageManagers = exports.PathLookup = exports.BunDetector = exports.DenoDetector = exports.YarnDetector = exports.PNpmDetector = exports.CNpmDetector = exports.NpmDetector = exports.PackageManagerDetector = exports.Runnable = void 0;
const promises_1 = __importDefault(require("node:fs/promises"));
const node_path_1 = __importDefault(require("node:path"));
class Runnable {
    executable;
    args;
    constructor(executable, args) {
        this.executable = executable;
        this.args = args;
    }
    get unsafeDisplayCommand() {
        return [this.executable, ...this.args.map(unsafeQuoteArg)].join(' ');
    }
}
exports.Runnable = Runnable;
/**
 * Quotes an argument for display purposes only.
 *
 * @returns The argument as-is if quoting is not required, or quoted otherwise.
 */
function unsafeQuoteArg(arg) {
    if (arg === '') {
        return `''`;
    }
    if (!/[^%+,-./:=@_0-9A-Za-z]/.test(arg)) {
        return arg;
    }
    return `'${arg.replaceAll(`'`, `'"'"'`)}'`;
}
class NotDetectedError extends Error {
}
class PackageManagerDetector {
}
exports.PackageManagerDetector = PackageManagerDetector;
class NpmDetector extends PackageManagerDetector {
    get name() {
        return 'npm';
    }
    detectUserAgent(userAgent) {
        return userAgent.startsWith('npm/');
    }
    detectRuntime() {
        return false;
    }
    async detectLockfile(dir) {
        return accessR(node_path_1.default.join(dir, 'package-lock.json'));
    }
    async detectExecutable(lookup) {
        await lookup.detectPresence('npm');
    }
    installCommand() {
        return new Runnable('npm', ['install']);
    }
    execCommand(args) {
        return new Runnable('npx', args);
    }
}
exports.NpmDetector = NpmDetector;
class CNpmDetector extends PackageManagerDetector {
    get name() {
        return 'cnpm';
    }
    detectUserAgent(userAgent) {
        return userAgent.startsWith('npminstall/');
    }
    detectRuntime() {
        return false;
    }
    async detectLockfile() {
        throw new NotDetectedError();
    }
    async detectExecutable(lookup) {
        await lookup.detectPresence('cnpm');
    }
    installCommand() {
        return new Runnable('cnpm', ['install']);
    }
    execCommand(args) {
        return new Runnable('npx', args);
    }
}
exports.CNpmDetector = CNpmDetector;
class PNpmDetector extends PackageManagerDetector {
    get name() {
        return 'pnpm';
    }
    detectUserAgent(userAgent) {
        return userAgent.startsWith('pnpm/');
    }
    detectRuntime() {
        return false;
    }
    async detectLockfile(dir) {
        return accessR(node_path_1.default.join(dir, 'pnpm-lock.yaml'));
    }
    async detectExecutable(lookup) {
        await lookup.detectPresence('pnpm');
    }
    installCommand() {
        return new Runnable('pnpm', ['install']);
    }
    execCommand(args) {
        return new Runnable('pnpm', args);
    }
}
exports.PNpmDetector = PNpmDetector;
class YarnDetector extends PackageManagerDetector {
    get name() {
        return 'yarn';
    }
    detectUserAgent(userAgent) {
        return userAgent.startsWith('yarn/');
    }
    detectRuntime() {
        return false;
    }
    async detectLockfile(dir) {
        return accessR(node_path_1.default.join(dir, 'yarn.lock'));
    }
    async detectExecutable(lookup) {
        await lookup.detectPresence('yarn');
    }
    installCommand() {
        return new Runnable('yarn', ['install']);
    }
    execCommand(args) {
        return new Runnable('yarn', args);
    }
}
exports.YarnDetector = YarnDetector;
class DenoDetector extends PackageManagerDetector {
    get name() {
        return 'deno';
    }
    detectUserAgent(userAgent) {
        return userAgent.startsWith('deno/');
    }
    detectRuntime() {
        return process.versions.deno !== undefined;
    }
    async detectLockfile(dir) {
        return accessR(node_path_1.default.join(dir, 'deno.lock'));
    }
    async detectExecutable(lookup) {
        await lookup.detectPresence('deno');
    }
    installCommand() {
        return new Runnable('deno', ['install']);
    }
    execCommand(args) {
        return new Runnable('deno', ['run', '-A', `npm:${args[0]}`, ...args.slice(1)]);
    }
}
exports.DenoDetector = DenoDetector;
class BunDetector extends PackageManagerDetector {
    get name() {
        return 'bun';
    }
    detectUserAgent(userAgent) {
        return userAgent.startsWith('bun/');
    }
    detectRuntime() {
        return process.versions.bun !== undefined;
    }
    async detectLockfile(dir) {
        return accessR(node_path_1.default.join(dir, 'bun.lockb'));
    }
    async detectExecutable(lookup) {
        await lookup.detectPresence('bun');
    }
    installCommand() {
        return new Runnable('bun', ['install']);
    }
    execCommand(args) {
        return new Runnable('bunx', args);
    }
}
exports.BunDetector = BunDetector;
async function accessR(filePath) {
    try {
        await promises_1.default.access(filePath, promises_1.default.constants.R_OK);
    }
    catch {
        throw new NotDetectedError();
    }
}
async function accessX(filePath) {
    try {
        await promises_1.default.access(filePath, promises_1.default.constants.X_OK);
    }
    catch {
        throw new NotDetectedError();
    }
}
function* chunks(array, size) {
    for (let i = 0, l = array.length; i < l; i += size) {
        yield array.slice(i, i + size);
    }
}
/**
 * Inspiration taken from https://github.com/otiai10/lookpath.
 */
class PathLookup {
    static win = process.platform.startsWith('win');
    paths;
    pathext;
    pathextSet = new Set();
    constructor() {
        if (PathLookup.win) {
            this.paths = process.env['Path']?.split(node_path_1.default.delimiter) ?? [];
            this.pathext = process.env['PATHEXT']?.split(node_path_1.default.delimiter) ?? [];
            this.pathext.forEach(ext => this.pathextSet.add(ext.toUpperCase()));
        }
        else {
            this.paths = process.env['PATH']?.split(node_path_1.default.delimiter) ?? [];
            this.pathext = [];
        }
    }
    async detectPresence(executable) {
        const foundPath = this.lookupPath(executable);
        if (foundPath === undefined) {
            throw new NotDetectedError();
        }
    }
    async lookupPath(executable) {
        const ext = node_path_1.default.extname(executable).toUpperCase();
        const paths = this.paths.flatMap(prefix => {
            if (this.pathextSet.has(ext)) {
                return [node_path_1.default.join(prefix, executable)];
            }
            return [
                node_path_1.default.join(prefix, executable),
                ...this.pathext.map(ext => node_path_1.default.join(prefix, executable + ext)),
            ];
        });
        // There may be a large number of paths. With Promise.all(), we'd have to
        // wait until every single possible path has been checked even if we found
        // a match immediately. Use reasonably sized chunks instead.
        //
        // On Windows (where PATHEXT exists), make sure that the chunk size is
        // at least large enough to cover all the possible extensions of a path.
        for (const chunk of chunks(paths, Math.max(this.pathext.length + 1, 8))) {
            const results = await Promise.all(chunk.map(async (path) => {
                try {
                    await accessX(path);
                    return path;
                }
                catch {
                    return;
                }
            }));
            for (const result of results) {
                if (result !== undefined) {
                    return result;
                }
            }
        }
    }
}
exports.PathLookup = PathLookup;
const npmDetector = new NpmDetector();
// The order of the detectors is relevant to the lookup order.
exports.knownPackageManagers = [
    new PNpmDetector(),
    new BunDetector(),
    new DenoDetector(),
    new YarnDetector(),
    new CNpmDetector(),
    npmDetector,
];
async function detectPackageManager(dir, options) {
    const detectors = options?.detectors ?? exports.knownPackageManagers;
    // Try user agent first.
    const userAgent = process.env['npm_config_user_agent'];
    if (userAgent !== undefined) {
        for (const detector of detectors) {
            if (detector.detectUserAgent(userAgent)) {
                return detector;
            }
        }
    }
    // Next, try runtime.
    for (const detector of detectors) {
        if (detector.detectRuntime()) {
            return detector;
        }
    }
    // Next, try to find a lockfile.
    try {
        return await Promise.any(detectors.map(async (detector) => {
            await detector.detectLockfile(dir);
            return detector;
        }));
    }
    catch {
        // Nothing detected.
    }
    // Finally, try to find a relevant executable.
    //
    // This can generate a whole bunch of path lookups. Try one by one despite
    // async support.
    const lookup = new PathLookup();
    for (const detector of detectors) {
        try {
            await detector.detectExecutable(lookup);
            return detector;
        }
        catch {
            continue;
        }
    }
    // If all else fails, just assume npm.
    return npmDetector;
}
exports.detectPackageManager = detectPackageManager;
//# sourceMappingURL=package-manager.js.map