"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isBuiltinPath = exports.isLocalPath = exports.PathResolver = void 0;
class TargetPathSpec {
    /**
     * Prefix is the part of the path before an asterisk (wildcard), or the
     * whole path if there's no asterisk.
     *
     * Examples of possible values:
     *   - `"./foo/*"` (from `"./foo/"`)
     *   - `"./bar/foo-"` (from `"./bar/foo-*.js"`)
     *   - `"./bar."` (from `"./bar.*.ts"`)
     *   - `""` (from `"*"`)
     */
    prefix;
    /**
     * Suffix is the part of the path after the asterisk (wildcard), if any.
     */
    suffix;
    constructor(prefix, suffix) {
        this.prefix = prefix;
        this.suffix = suffix;
    }
    toPath(joker) {
        if (this.suffix === undefined) {
            return this.prefix;
        }
        if (joker === undefined) {
            return this.prefix + this.suffix;
        }
        return this.prefix + joker + this.suffix;
    }
    static create(spec) {
        const parts = spec.split('*', 2);
        if (parts.length === 1) {
            return new TargetPathSpec(spec);
        }
        const [prefix, suffix] = parts;
        return new TargetPathSpec(prefix, suffix);
    }
}
class PathMatchResult {
    ok;
    results;
    constructor(ok, results) {
        this.ok = ok;
        this.results = results;
    }
    static some(results) {
        return new PathMatchResult(true, results);
    }
    static none() {
        return new PathMatchResult(false, []);
    }
}
class ExactPathMatcher {
    prefix;
    target;
    constructor(prefix, target) {
        this.prefix = prefix;
        this.target = target;
    }
    get prefixLength() {
        return this.prefix.length;
    }
    match(importPath) {
        if (importPath === this.prefix) {
            return PathMatchResult.some(this.target.map(target => {
                return {
                    spec: target,
                    path: target.toPath(),
                };
            }));
        }
        return PathMatchResult.none();
    }
}
class WildcardPathMatcher {
    prefix;
    suffix;
    target;
    constructor(prefix, suffix, target) {
        this.prefix = prefix;
        this.suffix = suffix;
        this.target = target;
    }
    get prefixLength() {
        return this.prefix.length;
    }
    match(importPath) {
        if (importPath.startsWith(this.prefix) && importPath.endsWith(this.suffix)) {
            const joker = importPath.substring(this.prefix.length, importPath.length - this.suffix.length);
            return PathMatchResult.some(this.target.map(target => {
                return {
                    spec: target,
                    path: target.toPath(joker),
                };
            }));
        }
        return PathMatchResult.none();
    }
}
class SourcePathSpec {
    /**
     * Prefix is the part of the path before an asterisk (wildcard), or the
     * whole path if there's no asterisk.
     *
     * Examples of possible values:
     *   - `"@/"` (from `"@/*"`)
     *   - `"app/foo-"` (from `"app/foo-*.js"`)
     *   - `"bar."` (from `"bar.*.ts"`)
     *   - `""` (from `"*"`)
     */
    prefix;
    /**
     * Suffix is the part of the path after the asterisk (wildcard), if any.
     */
    suffix;
    constructor(prefix, suffix) {
        this.prefix = prefix;
        this.suffix = suffix;
    }
    matcherForTarget(target) {
        if (this.suffix === undefined) {
            return new ExactPathMatcher(this.prefix, target);
        }
        return new WildcardPathMatcher(this.prefix, this.suffix, target);
    }
    static create(spec) {
        const parts = spec.split('*', 2);
        if (parts.length === 1) {
            return new SourcePathSpec(spec);
        }
        const [prefix, suffix] = parts;
        return new SourcePathSpec(prefix, suffix);
    }
}
class PathResolver {
    baseUrl;
    matchers;
    constructor(baseUrl, matchers) {
        this.baseUrl = baseUrl;
        // Sort by longest prefix now, then we don't have to care about it later.
        matchers.sort((a, b) => b.matcher.prefixLength - a.matcher.prefixLength);
        this.matchers = matchers;
    }
    resolve(importPath) {
        for (const { spec, matcher } of this.matchers) {
            const match = matcher.match(importPath);
            if (match.ok) {
                // We can just return the first match since matchers are already
                // sorted by longest prefix.
                return match.results.map(result => {
                    return {
                        source: {
                            spec,
                            path: importPath,
                        },
                        target: result,
                    };
                });
            }
        }
        return [];
    }
    static createFromPaths(baseUrl, paths) {
        const matchers = [];
        for (const path in paths) {
            matchers.push(PathResolver.matcherForPath(path, paths[path]));
        }
        return new PathResolver(baseUrl, matchers);
    }
    static matcherForPath(spec, target) {
        const pathSpec = SourcePathSpec.create(spec);
        const matcher = pathSpec.matcherForTarget(target.map(TargetPathSpec.create));
        return {
            spec: pathSpec,
            matcher,
        };
    }
}
exports.PathResolver = PathResolver;
function isLocalPath(importPath) {
    if (importPath.startsWith('/')) {
        return true;
    }
    if (importPath.startsWith('./')) {
        return true;
    }
    if (importPath.startsWith('../')) {
        return true;
    }
    return false;
}
exports.isLocalPath = isLocalPath;
function isBuiltinPath(importPath) {
    if (importPath.startsWith('node:')) {
        return true;
    }
    return false;
}
exports.isBuiltinPath = isBuiltinPath;
//# sourceMappingURL=paths.js.map