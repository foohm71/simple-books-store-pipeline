"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TSConfigFile = void 0;
const node_path_1 = __importDefault(require("node:path"));
const paths_1 = require("./paths");
class TSConfigFile {
    static FILENAME = 'tsconfig.json';
    static #id = 0;
    id = ++TSConfigFile.#id;
    jsonFile;
    basePath;
    moduleResolution;
    baseUrl;
    pathResolver;
    relatedSourceFiles = [];
    constructor(jsonFile) {
        this.jsonFile = jsonFile;
        this.basePath = jsonFile.meta.dirname;
        this.moduleResolution = jsonFile.data.compilerOptions?.moduleResolution?.toLocaleLowerCase() ?? 'unspecified';
        const baseUrl = jsonFile.data.compilerOptions?.baseUrl;
        if (baseUrl !== undefined) {
            this.baseUrl = node_path_1.default.resolve(this.jsonFile.meta.dirname, baseUrl);
        }
        this.pathResolver = paths_1.PathResolver.createFromPaths(this.baseUrl ?? '.', jsonFile.data.compilerOptions?.paths ?? {});
    }
    get meta() {
        return this.jsonFile.meta;
    }
    static loadFromJsonSourceFile(jsonFile) {
        return new TSConfigFile(jsonFile);
    }
    static filePath(dirPath) {
        return node_path_1.default.join(dirPath, TSConfigFile.FILENAME);
    }
    resolvePath(importPath) {
        return this.pathResolver.resolve(importPath);
    }
    collectLookupPaths(filePath) {
        let { 
        // eslint-disable-next-line prefer-const
        outDir, rootDir, 
        // eslint-disable-next-line prefer-const
        rootDirs, composite, } = this.jsonFile.data.compilerOptions ?? {};
        const candidates = [];
        if (outDir === undefined) {
            candidates.push(node_path_1.default.resolve(this.basePath, filePath));
            return candidates; // Nothing more we can do.
        }
        if (composite === undefined) {
            composite = false;
        }
        // Inferred rootDir is tsconfig directory if composite === true.
        if (rootDir === undefined && composite) {
            rootDir = '.';
        }
        // If we still don't have a root, we should calculate the longest common
        // path among input files, but that's a lot of effort. Assume tsconfig
        // directory and hope for the best.
        if (rootDir === undefined) {
            rootDir = '.';
        }
        const absoluteOutDir = node_path_1.default.resolve(this.basePath, outDir);
        const relativePath = node_path_1.default.relative(absoluteOutDir, filePath);
        // If the file is outside outDir, then assume we're looking for
        // something that wasn't compiled using this tsconfig (or at all), and
        // stop looking.
        if (relativePath.startsWith('..')) {
            candidates.push(node_path_1.default.resolve(this.basePath, filePath));
            return candidates;
        }
        candidates.push(node_path_1.default.resolve(this.basePath, rootDir, relativePath));
        // Assume that our inferred (or user specified) rootDir is enough to cover
        // the same conditions we'd have to infer rootDirs, and only add rootDirs
        // if they're actually set.
        for (const multiRootDir of rootDirs ?? []) {
            candidates.push(node_path_1.default.resolve(this.basePath, multiRootDir, relativePath));
        }
        return candidates;
    }
    registerRelatedSourceFile(file) {
        this.relatedSourceFiles.push(file);
    }
}
exports.TSConfigFile = TSConfigFile;
//# sourceMappingURL=tsconfig-json-file.js.map